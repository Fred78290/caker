import ArgumentParser
import CakedLib
import Dispatch
import GRPC
import GRPCLib
import Logging
import SwiftUI
import TextTable
import Virtualization

struct Networks: ParsableCommand {
	public struct VMNetOptions: ParsableArguments {
		@Flag(help: .private)
		public var debug: Bool = false

		@Argument(help: "socket path")
		public var socketPath: String? = nil

		@Option(name: [.customLong("fd")], help: "Use file descriptor for VMNet")
		public var vmfd: Int? = nil

		@Option(name: [.customLong("socket-group")], help: "socket group name")
		public var socketGroup: String = "staff"

		@Option(name: [.customLong("mode")], help: "vmnet mode")
		public var mode = VMNetMode.bridged

		@Option(name: [.customLong("interface")], help: ArgumentHelp("interface\n", discussion: "interface used for --vmnet=bridged, e.g., \"en0\""))
		public var networkName: String = ""

		@Option(name: [.customLong("mac-address")], help: ArgumentHelp("Mac Address of network interface\n", discussion: "Mac address configured for VM network interface, autogenerated if not specified", valueName: "mac"))
		public var macAddress: String = VZMACAddress.randomLocallyAdministered().string

		@Option(name: [.customLong("gateway")], help: ArgumentHelp("IP gateway\n", discussion: "gateway used for --vmnet=(host|shared), e.g., \"192.168.105.1\" (default: decided by macOS)"))
		public var gateway: String? = nil

		@Option(name: [.customLong("dhcp-end")], help: "end of the DHCP range")
		public var dhcpEnd: String? = nil

		@Option(help: "DHCP lease time in seconds")
		public var dhcpLease: Int32? = nil

		@Option(name: [.customLong("netmask")], help: ArgumentHelp("subnet mask\n", discussion: "requires --gateway to be specified"))
		public var subnetMask = "255.255.255.0"

		@Option(name: [.customLong("interface-id")], help: ArgumentHelp("vmnet interface ID\n", discussion: "randomly generated if not specified"))
		public var interfaceID = UUID().uuidString

		@Option(name: [.customLong("nat66-prefix")], help: "The IPv6 prefix to use with shared mode")
		public var nat66Prefix: String? = nil

		@Option(name: [.customLong("pidfile")], help: "save pid to PIDFILE")
		public var pidFile: String? = nil

		public init() {

		}

		public init(networkName: String, runMode: Utils.RunMode) throws {
			self.networkName = networkName

			self.debug = false
			self.networkName = networkName
			self.socketGroup = "staff"
			self.socketPath = nil
			self.vmfd = nil
			self.pidFile = nil

			if CakedLib.NetworksHandler.isPhysicalInterface(name: networkName) {
				self.mode = .bridged
				self.macAddress = VZMACAddress.randomLocallyAdministered().string
				self.gateway = nil
				self.dhcpEnd = nil
				self.dhcpLease = nil
				self.subnetMask = "255.255.255.0"
				self.interfaceID = UUID().uuidString
				self.nat66Prefix = nil
			} else {
				let home: Home = try Home(runMode: runMode)
				let networkConfig = try home.sharedNetworks()

				guard let network = networkConfig.sharedNetworks[networkName] else {
					throw ServiceError("Network \(networkName) doesn't exists")
				}

				self.mode = network.mode
				self.gateway = network.dhcpStart
				self.dhcpEnd = network.dhcpEnd
				self.dhcpLease = network.dhcpLease
				self.subnetMask = network.netmask
				self.interfaceID = network.interfaceID
				self.nat66Prefix = network.nat66Prefix
			}
		}

		func validate() throws {
			if self.vmfd != nil && self.socketPath != nil {
				throw ValidationError("fd and socket-path are mutually exclusive \(self.vmfd!) \(self.socketPath!)")
			}

			if let vmfd = self.vmfd {
				if self.pidFile == nil {
					throw ValidationError("pidfile is required when using fd")
				}

				guard fcntl(Int32(vmfd), F_GETFD) != -1 || errno != EBADF else {
					throw ValidationError("File descriptor is not open")
				}
			}

			if self.mode == .bridged {
				if self.networkName == "" {
					throw ValidationError("interface is required for bridged mode")
				}

				if self.gateway != nil {
					throw ValidationError("gateway is not allowed for bridged mode")
				}

				if self.dhcpEnd != nil {
					throw ValidationError("dhcp-end is not allowed for bridged mode")
				}
			} else if let gateway = self.gateway {
				guard let gatewayAddr = IP.V4(gateway) else {
					throw ValidationError("gateway is not a valid IP address")
				}

				guard let dhcpEnd = self.dhcpEnd else {
					throw ValidationError("dhcp-end is required for host/shared mode when gateway is specified")
				}

				guard let dhcpEndAddr = IP.V4(dhcpEnd) else {
					throw ValidationError("dhcp-end is not a valid IP address")
				}

				guard self.subnetMask.isValidNetmask() else {
					throw ValidationError("valid netmask is required for host/shared mode when gateway is specified")
				}

				let cidr = self.subnetMask.netmaskToCidr()
				let network = IP.Block<IP.V4>(base: gatewayAddr, bits: UInt8(cidr)).network

				if network.contains(dhcpEndAddr) == false {
					throw ValidationError("dhcp-end is not in the same network as gateway")
				}
			}
		}

		func vmnetEndpoint(runMode: Utils.RunMode) throws -> (URL, URL) {
			if let socketPath = self.socketPath, let pidFile = self.pidFile {
				return (URL(fileURLWithPath: socketPath), URL(fileURLWithPath: pidFile))
			} else {
				return try CakedLib.NetworksHandler.vmnetEndpoint(networkName: self.networkName, runMode: runMode)
			}
		}

		func createVZVMNet(runMode: Utils.RunMode) throws -> (URL, VZVMNet) {
			let network: VZSharedNetwork

			if CakedLib.NetworksHandler.isPhysicalInterface(name: self.networkName) {
				network = VZSharedNetwork(mode: self.mode, netmask: "", dhcpStart: "", dhcpEnd: "", dhcpLease: nil, interfaceID: self.interfaceID, nat66Prefix: nil)
			} else {
				network = VZSharedNetwork(mode: self.mode, netmask: self.subnetMask, dhcpStart: self.gateway!, dhcpEnd: self.dhcpEnd!, dhcpLease: self.dhcpLease, interfaceID: self.interfaceID, nat66Prefix: self.nat66Prefix)
			}

			guard let vmfd = self.vmfd else {
				let socketURL = try vmnetEndpoint(runMode: runMode)

				guard let grp = getgrnam(self.socketGroup) else {
					throw ServiceError("Failed to get group \(self.socketGroup)")
				}

				if let dhcpLease = self.dhcpLease {
					_ = try CakedLib.NetworksHandler.setDHCPLease(leaseTime: dhcpLease, runMode: runMode)
				}

				if try socketURL.0.exists() == false {
					let vzvmnet = VZVMNetSocket(
						on: Utilities.group.next(),
						socketPath: socketURL.0,
						socketGroup: grp.pointee.gr_gid,
						networkName: self.networkName,
						networkConfig: network,
						pidFile: socketURL.1
					)

					return (socketURL.1, vzvmnet)
				} else {
					throw ServiceError("Socket file already exists at \(socketURL.0.path)")
				}
			}

			guard let pidFile = self.pidFile else {
				throw ServiceError("pidfile is required when using vmfd")
			}

			let pidUrl = URL(fileURLWithPath: pidFile)

			try? pidUrl.delete()

			let vzvmnet = VZVMNetFileHandle(
				on: Utilities.group.next(),
				inputOutput: CInt(vmfd),
				networkName: self.networkName,
				networkConfig: network,
				pidFile: pidUrl)

			return (pidUrl, vzvmnet)
		}
	}

	static let configuration: CommandConfiguration = CommandConfiguration(
		abstract: "Manage host network devices",
		subcommands: [
			Networks.NatInfos.self,
			Networks.Infos.self,
			Networks.List.self,
			Networks.Create.self,
			Networks.Configure.self,
			Networks.DHCPLease.self,
			Networks.Delete.self,
			Networks.Run.self,
			Networks.Start.self,
			Networks.Restart.self,
			Networks.Stop.self,
		])

	static func validateNetwork(networkName: String, runMode: Utils.RunMode) throws {
		// Validate the network name
		if CakedLib.NetworksHandler.isPhysicalInterface(name: networkName) == false {
			let home: Home = try Home(runMode: runMode)
			let networkConfig = try home.sharedNetworks()

			if networkConfig.sharedNetworks[networkName] == nil {
				throw ValidationError("Network \(networkName) does not exist")
			}
		}
	}

	static func start(options: Networks.VMNetOptions, runMode: Utils.RunMode) -> StartedNetworkReply {
		do {
			let socketURL = try options.vmnetEndpoint(runMode: runMode)
			
			if socketURL.1.isCakedRunning() {
				return StartedNetworkReply(name: options.networkName, started: false, reason: "Network already running")
			}
			
			if geteuid() == 0 {
				let vzvmnet = try options.createVZVMNet(runMode: runMode)
				var signalReconfigure: DispatchSourceSignal? = nil
				
				if CakedLib.NetworksHandler.isPhysicalInterface(name: options.networkName) == false {
					let sig = DispatchSource.makeSignalSource(signal: SIGUSR2)
					
					if let dhcpLease = options.dhcpLease {
						_ = try CakedLib.NetworksHandler.setDHCPLease(leaseTime: dhcpLease, runMode: runMode)
					}
					
					Logger(self).info("Allow reconfigure network: \(options.networkName)")
					
					signal(SIGUSR2, SIG_IGN)
					
					sig.setEventHandler {
						Logger(self).info("Will reconfigure network: \(options.networkName)")
						
						do {
							let home: Home = try Home(runMode: runMode)
							let networkConfig = try home.sharedNetworks()
							
							if let network = networkConfig.sharedNetworks[options.networkName] {
								try? vzvmnet.1.reconfigure(networkConfig: network)
							}
						} catch {
							Logger(self).error("Failed to reconfigure network: \(error)")
							Foundation.exit(1)
						}
					}
					
					sig.activate()
					signalReconfigure = sig
				}
				
				defer {
					if let sig = signalReconfigure {
						sig.cancel()
					}
				}
				
				try vzvmnet.1.start()
				
				return StartedNetworkReply(name: options.networkName, started: true, reason: "Network \(options.networkName) started")
			} else if try SudoCaked(arguments: ["networks", "start", options.networkName], runMode: runMode, log: try CakedLib.NetworksHandler.vmnetFileLog(networkName: options.networkName, runMode: runMode)).run().terminationStatus != 0 {
				throw ServiceError("Failed to start networks \(options.networkName)")
			} else {
				let socketURL = try options.vmnetEndpoint(runMode: runMode)
				
				try socketURL.1.waitPID()
				
				return StartedNetworkReply(name: options.networkName, started: true, reason: "Network \(options.networkName) started")
			}
		} catch {
			return StartedNetworkReply(name: options.networkName, started: false, reason: "\(error)")
		}
	}

	struct NatInfos: ParsableCommand {
		static let configuration = CommandConfiguration(commandName: "nat-infos", abstract: "default nat network address", discussion: "This command is used retrieve the default nat network address", shouldDisplay: false)

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		func validate() throws {
			Logger.setLevel(self.common.logLevel)

			if geteuid() != 0 {
				throw ValidationError("This command must be run as root not as user \(geteuid())")
			}
		}

		func run() throws {
			Logger.appendNewLine(self.common.format.render(try CakedLib.NetworksHandler.natNetworkInfos()))
		}
	}

	struct Infos: ParsableCommand {
		static let configuration = NetworkInfoOptions.configuration

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@Argument(help: ArgumentHelp("Network name", discussion: "The name for network"))
		var name: String

		func validate() throws {
			Logger.setLevel(self.common.logLevel)

			try validateNetwork(networkName: self.name, runMode: self.common.runMode)
		}

		func run() throws {
			let result = CakedLib.NetworksHandler.status(networkName: self.name, runMode: self.common.runMode)
			
			if result.success {
				Logger.appendNewLine(self.common.format.render(result.info))
			} else {
				Logger.appendNewLine(self.common.format.render(result.reason))
			}
		}
	}

	struct DHCPLease: ParsableCommand {
		static let configuration = CommandConfiguration(commandName: "set-dhcp-lease", abstract: "Set DHCP lease duration.", discussion: "This command is used to set the dhcp lease")

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@Argument(help: "DHCP lease time in seconds")
		var dhcpLease: Int32 = 300

		func validate() throws {
			Logger.setLevel(self.common.logLevel)
		}

		func run() throws {
			Logger.appendNewLine(self.common.format.render(try CakedLib.NetworksHandler.setDHCPLease(leaseTime: self.dhcpLease, runMode: self.common.runMode)))
		}
	}

	struct Start: ParsableCommand {
		static let configuration = NetworkStartOptions.configuration

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@Argument(help: ArgumentHelp("Network name", discussion: "The name for network"))
		var name: String

		mutating func validate() throws {
			Logger.setLevel(self.common.logLevel)

			try validateNetwork(networkName: self.name, runMode: self.common.runMode)

			let socketURL = try CakedLib.NetworksHandler.vmnetEndpoint(networkName: name, runMode: self.common.runMode)

			if socketURL.1.isCakedRunning() {
				throw ValidationError("Network \(self.name) already running")
			}

			if FileManager.default.fileExists(atPath: socketURL.0.path) {
				throw ValidationError("Network \(self.name) already running")
			}
		}

		func run() throws {
			Logger.appendNewLine(self.common.format.render(Networks.start(options: try Networks.VMNetOptions(networkName: self.name, runMode: self.common.runMode), runMode: self.common.runMode)))
		}
	}

	struct Restart: ParsableCommand {
		static let configuration = CommandConfiguration(abstract: "Restart named network.", discussion: "This command is used to restart the VMNet network device.")

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@Argument(help: ArgumentHelp("Network name", discussion: "The name for network"))
		var name: String

		mutating func validate() throws {
			Logger.setLevel(self.common.logLevel)

			try validateNetwork(networkName: self.name, runMode: self.common.runMode)

			let socketURL = try CakedLib.NetworksHandler.vmnetEndpoint(networkName: name, runMode: self.common.runMode)

			if FileManager.default.fileExists(atPath: socketURL.0.path) == false {
				throw ValidationError("Network \(self.name) is not running")
			}
		}

		func run() throws {
			Logger.appendNewLine(self.common.format.render(try CakedLib.NetworksHandler.restartNetworkService(networkName: self.name, runMode: self.common.runMode)))
		}
	}

	struct Create: AsyncParsableCommand {
		static let configuration = NetworkCreateOptions.configuration

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@OptionGroup(title: "Create networks options")
		var options: NetworkCreateOptions

		var createdNetwork: VZSharedNetwork? = nil

		mutating func validate() throws {
			Logger.setLevel(self.common.logLevel)

			let home: Home = try Home(runMode: self.common.runMode)
			let networkConfig = try home.sharedNetworks()

			if networkConfig.sharedNetworks[self.options.name] != nil {
				throw ValidationError("Network \(self.options.name) already exist")
			}

			if CakedLib.NetworksHandler.isPhysicalInterface(name: self.options.name) {
				throw ValidationError("Network \(self.options.name) is a physical interface")
			}

			let network = VZSharedNetwork(
				mode: self.options.mode == .shared ? .shared : .host,
				netmask: self.options.subnetMask,
				dhcpStart: self.options.gateway,
				dhcpEnd: self.options.dhcpEnd,
				dhcpLease: self.options.dhcpLease,
				interfaceID: self.options.interfaceID,
				nat66Prefix: self.options.nat66Prefix
			)

			try network.validate(runMode: common.runMode)
			self.createdNetwork = network
		}

		func run() async throws {
			Logger.appendNewLine(self.common.format.render(CakedLib.NetworksHandler.create(networkName: self.options.name, network: self.createdNetwork!, runMode: self.common.runMode)))
		}
	}

	struct Configure: ParsableCommand {
		static let configuration = NetworkConfigureOptions.configuration

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@OptionGroup(title: "Configure networks options")
		var options: NetworkConfigureOptions

		var changedNetwork: VZSharedNetwork? = nil

		mutating func validate() throws {
			Logger.setLevel(self.common.logLevel)

			let home: Home = try Home(runMode: self.common.runMode)
			let networkConfig = try home.sharedNetworks()

			if CakedLib.NetworksHandler.isPhysicalInterface(name: self.options.name) {
				throw ValidationError("Unable to configure physical network \(self.options.name)")
			}

			guard let existing = networkConfig.sharedNetworks[self.options.name] else {
				throw ValidationError("Network \(self.options.name) does not exist")
			}

			let changed = VZSharedNetwork(
				mode: existing.mode,
				netmask: self.options.subnetMask ?? existing.netmask,
				dhcpStart: self.options.gateway ?? existing.dhcpStart,
				dhcpEnd: self.options.dhcpEnd ?? existing.dhcpEnd,
				dhcpLease: self.options.dhcpLease ?? existing.dhcpLease,
				interfaceID: self.options.interfaceID ?? existing.interfaceID,
				nat66Prefix: self.options.nat66Prefix ?? existing.nat66Prefix
			)

			if existing != changed {
				try changed.validate(runMode: common.runMode)
			}

			self.changedNetwork = changed
		}

		func run() throws {
			Logger.appendNewLine(self.common.format.render(CakedLib.NetworksHandler.configure(networkName: self.options.name, network: self.changedNetwork!, runMode: self.common.runMode)))
		}
	}

	struct Delete: ParsableCommand {
		static let configuration = NetworkDeleteOptions.configuration

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@Argument(help: ArgumentHelp("network name", discussion: "network to delete, e.g. \"shared\""))
		var name: String

		mutating func validate() throws {
			Logger.setLevel(self.common.logLevel)

			let home: Home = try Home(runMode: self.common.runMode)
			let networkConfig = try home.sharedNetworks()
			let socketURL = try CakedLib.NetworksHandler.vmnetEndpoint(networkName: self.name, runMode: self.common.runMode)

			if FileManager.default.fileExists(atPath: socketURL.0.path) {
				throw ValidationError("Unable to delete running network \(self.name)")
			}

			if CakedLib.NetworksHandler.isPhysicalInterface(name: self.name) {
				throw ValidationError("Unable to delete physical network \(self.name)")
			}

			if networkConfig.sharedNetworks[self.name] == nil {
				throw ValidationError("Network \(self.name) does not exist")
			}
		}

		func run() throws {
			Logger.appendNewLine(self.common.format.render(CakedLib.NetworksHandler.delete(networkName: self.name, runMode: self.common.runMode)))
		}
	}

	struct Run: AsyncParsableCommand {
		static let configuration = CommandConfiguration(abstract: "Run internal VMNet network device", shouldDisplay: false)

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@OptionGroup(title: "Configure VMNet options")
		var options: Networks.VMNetOptions

		mutating func validate() throws {
			Logger.setLevel(self.common.logLevel)

			let socketURL = try self.options.vmnetEndpoint(runMode: self.common.runMode)

			if FileManager.default.fileExists(atPath: socketURL.0.path) {
				throw ValidationError("Network already running")
			}

			if geteuid() != 0 {
				throw ValidationError("This command must be run as root not as user \(geteuid())")
			}

			if FileManager.default.fileExists(atPath: socketURL.0.path) {
				throw ValidationError("Network already running")
			}

			try self.options.validate()
		}

		func run() async throws {
			Logger.appendNewLine(self.common.format.render(Networks.start(options: self.options, runMode: self.common.runMode)))
		}
	}

	struct Stop: ParsableCommand {
		static let configuration = NetworkStopOptions.configuration

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		@Argument(help: ArgumentHelp("network name", discussion: "network to stop, e.g., \"en0\" or \"shared\""))
		var networkName: String? = nil

		@Option(name: [.customLong("pidfile")], help: .hidden)
		var pidFile: String? = nil

		func validate() throws {
			Logger.setLevel(self.common.logLevel)

			if networkName != nil && pidFile != nil {
				throw ValidationError("You can only specify one of --network or --pidfile")
			}

			if networkName == nil && pidFile == nil {
				throw ValidationError("You must specify one of --network or --pidfile")
			}

			if let networkName {
				try Networks.validateNetwork(networkName: networkName, runMode: self.common.runMode)
			} else if let pidFile {
				if !FileManager.default.fileExists(atPath: pidFile) {
					throw ValidationError("PID file \(pidFile) does not exist")
				}
			}
		}

		func run() throws {
			if let pidFile {
				Logger.appendNewLine(self.common.format.render(CakedLib.NetworksHandler.stop(pidURL: URL(fileURLWithPath: pidFile), runMode: self.common.runMode)))
			} else if let networkName {
				Logger.appendNewLine(self.common.format.render(CakedLib.NetworksHandler.stop(networkName: networkName, runMode: self.common.runMode)))
			} else {
				throw ValidationError("No network name provided")
			}
		}
	}

	struct List: ParsableCommand {
		static let configuration = NetworkListOptions.configuration

		@OptionGroup(title: "Global options")
		var common: CommonOptions

		mutating func validate() throws {
			Logger.setLevel(self.common.logLevel)
		}

		func run() throws {
			let result = CakedLib.NetworksHandler.networks(runMode: self.common.runMode)

			if result.success {
				Logger.appendNewLine(self.common.format.render(result.networks))
			} else {
				Logger.appendNewLine(self.common.format.render(result.reason))
			}
		}
	}
}
