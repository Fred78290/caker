// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Caked_Format: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case text // = 0
  case json // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .text
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .text
    case 1: self = .json
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .text: return 0
    case .json: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Caked_Format] = [
    .text,
    .json,
  ]

}

public enum Caked_RemoteCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case add // = 1
  case delete // = 2
  case list // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .add
    case 2: self = .delete
    case 3: self = .list
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .add: return 1
    case .delete: return 2
    case .list: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Caked_RemoteCommand] = [
    .none,
    .add,
    .delete,
    .list,
  ]

}

public struct Caked_StopRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_WaitIPRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var timeout: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_NetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: Caked_Format = .text

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_RemoteRequestAdd: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_RemoteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: Caked_RemoteCommand = .none

  public var request: Caked_RemoteRequest.OneOf_Request? = nil

  public var add: Caked_RemoteRequestAdd {
    get {
      if case .add(let v)? = request {return v}
      return Caked_RemoteRequestAdd()
    }
    set {request = .add(newValue)}
  }

  public var delete: String {
    get {
      if case .delete(let v)? = request {return v}
      return String()
    }
    set {request = .delete(newValue)}
  }

  public var format: Caked_Format {
    get {
      if case .format(let v)? = request {return v}
      return .text
    }
    set {request = .format(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case add(Caked_RemoteRequestAdd)
    case delete(String)
    case format(Caked_Format)

  }

  public init() {}
}

public struct Caked_Bytes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_CakedCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: String = String()

  public var arguments: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_CommonBuildRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var cpu: Int32 {
    get {return _storage._cpu ?? 0}
    set {_uniqueStorage()._cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  public var hasCpu: Bool {return _storage._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  public mutating func clearCpu() {_uniqueStorage()._cpu = nil}

  public var memory: Int32 {
    get {return _storage._memory ?? 0}
    set {_uniqueStorage()._memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  public var hasMemory: Bool {return _storage._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  public mutating func clearMemory() {_uniqueStorage()._memory = nil}

  public var user: String {
    get {return _storage._user ?? String()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var password: String {
    get {return _storage._password ?? String()}
    set {_uniqueStorage()._password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  public var hasPassword: Bool {return _storage._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  public mutating func clearPassword() {_uniqueStorage()._password = nil}

  public var mainGroup: String {
    get {return _storage._mainGroup ?? String()}
    set {_uniqueStorage()._mainGroup = newValue}
  }
  /// Returns true if `mainGroup` has been explicitly set.
  public var hasMainGroup: Bool {return _storage._mainGroup != nil}
  /// Clears the value of `mainGroup`. Subsequent reads from it will return its default value.
  public mutating func clearMainGroup() {_uniqueStorage()._mainGroup = nil}

  public var sshPwAuth: Bool {
    get {return _storage._sshPwAuth ?? false}
    set {_uniqueStorage()._sshPwAuth = newValue}
  }
  /// Returns true if `sshPwAuth` has been explicitly set.
  public var hasSshPwAuth: Bool {return _storage._sshPwAuth != nil}
  /// Clears the value of `sshPwAuth`. Subsequent reads from it will return its default value.
  public mutating func clearSshPwAuth() {_uniqueStorage()._sshPwAuth = nil}

  public var image: String {
    get {return _storage._image ?? String()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var sshAuthorizedKey: Data {
    get {return _storage._sshAuthorizedKey ?? Data()}
    set {_uniqueStorage()._sshAuthorizedKey = newValue}
  }
  /// Returns true if `sshAuthorizedKey` has been explicitly set.
  public var hasSshAuthorizedKey: Bool {return _storage._sshAuthorizedKey != nil}
  /// Clears the value of `sshAuthorizedKey`. Subsequent reads from it will return its default value.
  public mutating func clearSshAuthorizedKey() {_uniqueStorage()._sshAuthorizedKey = nil}

  public var vendorData: Data {
    get {return _storage._vendorData ?? Data()}
    set {_uniqueStorage()._vendorData = newValue}
  }
  /// Returns true if `vendorData` has been explicitly set.
  public var hasVendorData: Bool {return _storage._vendorData != nil}
  /// Clears the value of `vendorData`. Subsequent reads from it will return its default value.
  public mutating func clearVendorData() {_uniqueStorage()._vendorData = nil}

  public var userData: Data {
    get {return _storage._userData ?? Data()}
    set {_uniqueStorage()._userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  public var hasUserData: Bool {return _storage._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  public mutating func clearUserData() {_uniqueStorage()._userData = nil}

  public var networkConfig: Data {
    get {return _storage._networkConfig ?? Data()}
    set {_uniqueStorage()._networkConfig = newValue}
  }
  /// Returns true if `networkConfig` has been explicitly set.
  public var hasNetworkConfig: Bool {return _storage._networkConfig != nil}
  /// Clears the value of `networkConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkConfig() {_uniqueStorage()._networkConfig = nil}

  public var diskSize: Int32 {
    get {return _storage._diskSize ?? 0}
    set {_uniqueStorage()._diskSize = newValue}
  }
  /// Returns true if `diskSize` has been explicitly set.
  public var hasDiskSize: Bool {return _storage._diskSize != nil}
  /// Clears the value of `diskSize`. Subsequent reads from it will return its default value.
  public mutating func clearDiskSize() {_uniqueStorage()._diskSize = nil}

  public var autostart: Bool {
    get {return _storage._autostart ?? false}
    set {_uniqueStorage()._autostart = newValue}
  }
  /// Returns true if `autostart` has been explicitly set.
  public var hasAutostart: Bool {return _storage._autostart != nil}
  /// Clears the value of `autostart`. Subsequent reads from it will return its default value.
  public mutating func clearAutostart() {_uniqueStorage()._autostart = nil}

  public var nested: Bool {
    get {return _storage._nested ?? false}
    set {_uniqueStorage()._nested = newValue}
  }
  /// Returns true if `nested` has been explicitly set.
  public var hasNested: Bool {return _storage._nested != nil}
  /// Clears the value of `nested`. Subsequent reads from it will return its default value.
  public mutating func clearNested() {_uniqueStorage()._nested = nil}

  public var forwardedPort: String {
    get {return _storage._forwardedPort ?? String()}
    set {_uniqueStorage()._forwardedPort = newValue}
  }
  /// Returns true if `forwardedPort` has been explicitly set.
  public var hasForwardedPort: Bool {return _storage._forwardedPort != nil}
  /// Clears the value of `forwardedPort`. Subsequent reads from it will return its default value.
  public mutating func clearForwardedPort() {_uniqueStorage()._forwardedPort = nil}

  public var mounts: String {
    get {return _storage._mounts ?? String()}
    set {_uniqueStorage()._mounts = newValue}
  }
  /// Returns true if `mounts` has been explicitly set.
  public var hasMounts: Bool {return _storage._mounts != nil}
  /// Clears the value of `mounts`. Subsequent reads from it will return its default value.
  public mutating func clearMounts() {_uniqueStorage()._mounts = nil}

  public var netBridged: String {
    get {return _storage._netBridged ?? String()}
    set {_uniqueStorage()._netBridged = newValue}
  }
  /// Returns true if `netBridged` has been explicitly set.
  public var hasNetBridged: Bool {return _storage._netBridged != nil}
  /// Clears the value of `netBridged`. Subsequent reads from it will return its default value.
  public mutating func clearNetBridged() {_uniqueStorage()._netBridged = nil}

  public var netSofnet: Bool {
    get {return _storage._netSofnet ?? false}
    set {_uniqueStorage()._netSofnet = newValue}
  }
  /// Returns true if `netSofnet` has been explicitly set.
  public var hasNetSofnet: Bool {return _storage._netSofnet != nil}
  /// Clears the value of `netSofnet`. Subsequent reads from it will return its default value.
  public mutating func clearNetSofnet() {_uniqueStorage()._netSofnet = nil}

  public var netSoftnetAllow: String {
    get {return _storage._netSoftnetAllow ?? String()}
    set {_uniqueStorage()._netSoftnetAllow = newValue}
  }
  /// Returns true if `netSoftnetAllow` has been explicitly set.
  public var hasNetSoftnetAllow: Bool {return _storage._netSoftnetAllow != nil}
  /// Clears the value of `netSoftnetAllow`. Subsequent reads from it will return its default value.
  public mutating func clearNetSoftnetAllow() {_uniqueStorage()._netSoftnetAllow = nil}

  public var netHost: Bool {
    get {return _storage._netHost ?? false}
    set {_uniqueStorage()._netHost = newValue}
  }
  /// Returns true if `netHost` has been explicitly set.
  public var hasNetHost: Bool {return _storage._netHost != nil}
  /// Clears the value of `netHost`. Subsequent reads from it will return its default value.
  public mutating func clearNetHost() {_uniqueStorage()._netHost = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Caked_BuildRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: Caked_CommonBuildRequest {
    get {return _options ?? Caked_CommonBuildRequest()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Caked_CommonBuildRequest? = nil
}

public struct Caked_LaunchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: Caked_CommonBuildRequest {
    get {return _options ?? Caked_CommonBuildRequest()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var waitIptimeout: Int32 {
    get {return _waitIptimeout ?? 0}
    set {_waitIptimeout = newValue}
  }
  /// Returns true if `waitIptimeout` has been explicitly set.
  public var hasWaitIptimeout: Bool {return self._waitIptimeout != nil}
  /// Clears the value of `waitIptimeout`. Subsequent reads from it will return its default value.
  public mutating func clearWaitIptimeout() {self._waitIptimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Caked_CommonBuildRequest? = nil
  fileprivate var _waitIptimeout: Int32? = nil
}

public struct Caked_StartRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var waitIptimeout: Int32 {
    get {return _waitIptimeout ?? 0}
    set {_waitIptimeout = newValue}
  }
  /// Returns true if `waitIptimeout` has been explicitly set.
  public var hasWaitIptimeout: Bool {return self._waitIptimeout != nil}
  /// Clears the value of `waitIptimeout`. Subsequent reads from it will return its default value.
  public mutating func clearWaitIptimeout() {self._waitIptimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _waitIptimeout: Int32? = nil
}

public struct Caked_Error: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_PurgeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entries: String {
    get {return _entries ?? String()}
    set {_entries = newValue}
  }
  /// Returns true if `entries` has been explicitly set.
  public var hasEntries: Bool {return self._entries != nil}
  /// Clears the value of `entries`. Subsequent reads from it will return its default value.
  public mutating func clearEntries() {self._entries = nil}

  public var olderThan: Int32 {
    get {return _olderThan ?? 0}
    set {_olderThan = newValue}
  }
  /// Returns true if `olderThan` has been explicitly set.
  public var hasOlderThan: Bool {return self._olderThan != nil}
  /// Clears the value of `olderThan`. Subsequent reads from it will return its default value.
  public mutating func clearOlderThan() {self._olderThan = nil}

  public var cacheBudget: Int32 {
    get {return _cacheBudget ?? 0}
    set {_cacheBudget = newValue}
  }
  /// Returns true if `cacheBudget` has been explicitly set.
  public var hasCacheBudget: Bool {return self._cacheBudget != nil}
  /// Clears the value of `cacheBudget`. Subsequent reads from it will return its default value.
  public mutating func clearCacheBudget() {self._cacheBudget = nil}

  public var spaceBudget: Int32 {
    get {return _spaceBudget ?? 0}
    set {_spaceBudget = newValue}
  }
  /// Returns true if `spaceBudget` has been explicitly set.
  public var hasSpaceBudget: Bool {return self._spaceBudget != nil}
  /// Clears the value of `spaceBudget`. Subsequent reads from it will return its default value.
  public mutating func clearSpaceBudget() {self._spaceBudget = nil}

  public var gc: Bool {
    get {return _gc ?? false}
    set {_gc = newValue}
  }
  /// Returns true if `gc` has been explicitly set.
  public var hasGc: Bool {return self._gc != nil}
  /// Clears the value of `gc`. Subsequent reads from it will return its default value.
  public mutating func clearGc() {self._gc = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entries: String? = nil
  fileprivate var _olderThan: Int32? = nil
  fileprivate var _cacheBudget: Int32? = nil
  fileprivate var _spaceBudget: Int32? = nil
  fileprivate var _gc: Bool? = nil
}

public struct Caked_ConfigureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var cpu: Int32 {
    get {return _cpu ?? 0}
    set {_cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  public var hasCpu: Bool {return self._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  public mutating func clearCpu() {self._cpu = nil}

  public var memory: Int32 {
    get {return _memory ?? 0}
    set {_memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  public var hasMemory: Bool {return self._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  public mutating func clearMemory() {self._memory = nil}

  public var diskSize: Int32 {
    get {return _diskSize ?? 0}
    set {_diskSize = newValue}
  }
  /// Returns true if `diskSize` has been explicitly set.
  public var hasDiskSize: Bool {return self._diskSize != nil}
  /// Clears the value of `diskSize`. Subsequent reads from it will return its default value.
  public mutating func clearDiskSize() {self._diskSize = nil}

  public var displayRefit: Bool {
    get {return _displayRefit ?? false}
    set {_displayRefit = newValue}
  }
  /// Returns true if `displayRefit` has been explicitly set.
  public var hasDisplayRefit: Bool {return self._displayRefit != nil}
  /// Clears the value of `displayRefit`. Subsequent reads from it will return its default value.
  public mutating func clearDisplayRefit() {self._displayRefit = nil}

  public var autostart: Bool {
    get {return _autostart ?? false}
    set {_autostart = newValue}
  }
  /// Returns true if `autostart` has been explicitly set.
  public var hasAutostart: Bool {return self._autostart != nil}
  /// Clears the value of `autostart`. Subsequent reads from it will return its default value.
  public mutating func clearAutostart() {self._autostart = nil}

  public var nested: Bool {
    get {return _nested ?? false}
    set {_nested = newValue}
  }
  /// Returns true if `nested` has been explicitly set.
  public var hasNested: Bool {return self._nested != nil}
  /// Clears the value of `nested`. Subsequent reads from it will return its default value.
  public mutating func clearNested() {self._nested = nil}

  public var mounts: String {
    get {return _mounts ?? String()}
    set {_mounts = newValue}
  }
  /// Returns true if `mounts` has been explicitly set.
  public var hasMounts: Bool {return self._mounts != nil}
  /// Clears the value of `mounts`. Subsequent reads from it will return its default value.
  public mutating func clearMounts() {self._mounts = nil}

  public var netBridged: String {
    get {return _netBridged ?? String()}
    set {_netBridged = newValue}
  }
  /// Returns true if `netBridged` has been explicitly set.
  public var hasNetBridged: Bool {return self._netBridged != nil}
  /// Clears the value of `netBridged`. Subsequent reads from it will return its default value.
  public mutating func clearNetBridged() {self._netBridged = nil}

  public var netSoftnet: Bool {
    get {return _netSoftnet ?? false}
    set {_netSoftnet = newValue}
  }
  /// Returns true if `netSoftnet` has been explicitly set.
  public var hasNetSoftnet: Bool {return self._netSoftnet != nil}
  /// Clears the value of `netSoftnet`. Subsequent reads from it will return its default value.
  public mutating func clearNetSoftnet() {self._netSoftnet = nil}

  public var netSoftnetAllow: String {
    get {return _netSoftnetAllow ?? String()}
    set {_netSoftnetAllow = newValue}
  }
  /// Returns true if `netSoftnetAllow` has been explicitly set.
  public var hasNetSoftnetAllow: Bool {return self._netSoftnetAllow != nil}
  /// Clears the value of `netSoftnetAllow`. Subsequent reads from it will return its default value.
  public mutating func clearNetSoftnetAllow() {self._netSoftnetAllow = nil}

  public var netHost: Bool {
    get {return _netHost ?? false}
    set {_netHost = newValue}
  }
  /// Returns true if `netHost` has been explicitly set.
  public var hasNetHost: Bool {return self._netHost != nil}
  /// Clears the value of `netHost`. Subsequent reads from it will return its default value.
  public mutating func clearNetHost() {self._netHost = nil}

  public var randomMac: Bool {
    get {return _randomMac ?? false}
    set {_randomMac = newValue}
  }
  /// Returns true if `randomMac` has been explicitly set.
  public var hasRandomMac: Bool {return self._randomMac != nil}
  /// Clears the value of `randomMac`. Subsequent reads from it will return its default value.
  public mutating func clearRandomMac() {self._randomMac = nil}

  public var forwardedPort: String {
    get {return _forwardedPort ?? String()}
    set {_forwardedPort = newValue}
  }
  /// Returns true if `forwardedPort` has been explicitly set.
  public var hasForwardedPort: Bool {return self._forwardedPort != nil}
  /// Clears the value of `forwardedPort`. Subsequent reads from it will return its default value.
  public mutating func clearForwardedPort() {self._forwardedPort = nil}

  public var resetForwardedPort: Bool {
    get {return _resetForwardedPort ?? false}
    set {_resetForwardedPort = newValue}
  }
  /// Returns true if `resetForwardedPort` has been explicitly set.
  public var hasResetForwardedPort: Bool {return self._resetForwardedPort != nil}
  /// Clears the value of `resetForwardedPort`. Subsequent reads from it will return its default value.
  public mutating func clearResetForwardedPort() {self._resetForwardedPort = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cpu: Int32? = nil
  fileprivate var _memory: Int32? = nil
  fileprivate var _diskSize: Int32? = nil
  fileprivate var _displayRefit: Bool? = nil
  fileprivate var _autostart: Bool? = nil
  fileprivate var _nested: Bool? = nil
  fileprivate var _mounts: String? = nil
  fileprivate var _netBridged: String? = nil
  fileprivate var _netSoftnet: Bool? = nil
  fileprivate var _netSoftnetAllow: String? = nil
  fileprivate var _netHost: Bool? = nil
  fileprivate var _randomMac: Bool? = nil
  fileprivate var _forwardedPort: String? = nil
  fileprivate var _resetForwardedPort: Bool? = nil
}

public struct Caked_LoginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var username: String = String()

  public var password: String = String()

  public var insecure: Bool = false

  public var noValidate: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_Reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Caked_Reply.OneOf_Response? = nil

  public var error: Caked_Error {
    get {
      if case .error(let v)? = response {return v}
      return Caked_Error()
    }
    set {response = .error(newValue)}
  }

  public var output: String {
    get {
      if case .output(let v)? = response {return v}
      return String()
    }
    set {response = .output(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case error(Caked_Error)
    case output(String)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "caked"

extension Caked_Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "text"),
    1: .same(proto: "json"),
  ]
}

extension Caked_RemoteCommand: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "add"),
    2: .same(proto: "delete"),
    3: .same(proto: "list"),
  ]
}

extension Caked_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_StopRequest, rhs: Caked_StopRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_WaitIPRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitIPRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt32Field(value: self.timeout, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_WaitIPRequest, rhs: Caked_WaitIPRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_NetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.format != .text {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_NetworkRequest, rhs: Caked_NetworkRequest) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_RemoteRequestAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteRequestAdd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_RemoteRequestAdd, rhs: Caked_RemoteRequestAdd) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_RemoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "add"),
    3: .same(proto: "delete"),
    4: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try {
        var v: Caked_RemoteRequestAdd?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .add(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .add(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.request != nil {try decoder.handleConflictingOneOf()}
          self.request = .delete(v)
        }
      }()
      case 4: try {
        var v: Caked_Format?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.request != nil {try decoder.handleConflictingOneOf()}
          self.request = .format(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    switch self.request {
    case .add?: try {
      guard case .add(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .format?: try {
      guard case .format(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_RemoteRequest, rhs: Caked_RemoteRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Bytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bytes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Bytes, rhs: Caked_Bytes) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_CakedCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CakedCommandRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "arguments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_CakedCommandRequest, rhs: Caked_CakedCommandRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_CommonBuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommonBuildRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "cpu"),
    3: .same(proto: "memory"),
    4: .same(proto: "user"),
    22: .same(proto: "password"),
    5: .same(proto: "mainGroup"),
    6: .same(proto: "sshPwAuth"),
    7: .same(proto: "image"),
    8: .same(proto: "sshAuthorizedKey"),
    9: .same(proto: "vendorData"),
    10: .same(proto: "userData"),
    11: .same(proto: "networkConfig"),
    12: .same(proto: "diskSize"),
    13: .same(proto: "autostart"),
    14: .same(proto: "nested"),
    15: .same(proto: "forwardedPort"),
    16: .same(proto: "mounts"),
    17: .same(proto: "netBridged"),
    18: .same(proto: "netSofnet"),
    19: .same(proto: "netSoftnetAllow"),
    21: .same(proto: "netHost"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _cpu: Int32? = nil
    var _memory: Int32? = nil
    var _user: String? = nil
    var _password: String? = nil
    var _mainGroup: String? = nil
    var _sshPwAuth: Bool? = nil
    var _image: String? = nil
    var _sshAuthorizedKey: Data? = nil
    var _vendorData: Data? = nil
    var _userData: Data? = nil
    var _networkConfig: Data? = nil
    var _diskSize: Int32? = nil
    var _autostart: Bool? = nil
    var _nested: Bool? = nil
    var _forwardedPort: String? = nil
    var _mounts: String? = nil
    var _netBridged: String? = nil
    var _netSofnet: Bool? = nil
    var _netSoftnetAllow: String? = nil
    var _netHost: Bool? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _cpu = source._cpu
      _memory = source._memory
      _user = source._user
      _password = source._password
      _mainGroup = source._mainGroup
      _sshPwAuth = source._sshPwAuth
      _image = source._image
      _sshAuthorizedKey = source._sshAuthorizedKey
      _vendorData = source._vendorData
      _userData = source._userData
      _networkConfig = source._networkConfig
      _diskSize = source._diskSize
      _autostart = source._autostart
      _nested = source._nested
      _forwardedPort = source._forwardedPort
      _mounts = source._mounts
      _netBridged = source._netBridged
      _netSofnet = source._netSofnet
      _netSoftnetAllow = source._netSoftnetAllow
      _netHost = source._netHost
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._cpu) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._memory) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._mainGroup) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._sshPwAuth) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._image) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._sshAuthorizedKey) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._vendorData) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._userData) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._networkConfig) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._diskSize) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._autostart) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._nested) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._forwardedPort) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._mounts) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._netBridged) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._netSofnet) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._netSoftnetAllow) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._netHost) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._password) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._cpu {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memory {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._mainGroup {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sshPwAuth {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sshAuthorizedKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._vendorData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._userData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._networkConfig {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._diskSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._autostart {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._nested {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._forwardedPort {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._mounts {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._netBridged {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._netSofnet {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._netSoftnetAllow {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._netHost {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._password {
        try visitor.visitSingularStringField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_CommonBuildRequest, rhs: Caked_CommonBuildRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._password != rhs_storage._password {return false}
        if _storage._mainGroup != rhs_storage._mainGroup {return false}
        if _storage._sshPwAuth != rhs_storage._sshPwAuth {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._sshAuthorizedKey != rhs_storage._sshAuthorizedKey {return false}
        if _storage._vendorData != rhs_storage._vendorData {return false}
        if _storage._userData != rhs_storage._userData {return false}
        if _storage._networkConfig != rhs_storage._networkConfig {return false}
        if _storage._diskSize != rhs_storage._diskSize {return false}
        if _storage._autostart != rhs_storage._autostart {return false}
        if _storage._nested != rhs_storage._nested {return false}
        if _storage._forwardedPort != rhs_storage._forwardedPort {return false}
        if _storage._mounts != rhs_storage._mounts {return false}
        if _storage._netBridged != rhs_storage._netBridged {return false}
        if _storage._netSofnet != rhs_storage._netSofnet {return false}
        if _storage._netSoftnetAllow != rhs_storage._netSoftnetAllow {return false}
        if _storage._netHost != rhs_storage._netHost {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_BuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_BuildRequest, rhs: Caked_BuildRequest) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_LaunchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LaunchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
    2: .same(proto: "waitIPTimeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._waitIptimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._waitIptimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_LaunchRequest, rhs: Caked_LaunchRequest) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs._waitIptimeout != rhs._waitIptimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_StartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "waitIPTimeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._waitIptimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._waitIptimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_StartRequest, rhs: Caked_StartRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._waitIptimeout != rhs._waitIptimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Error, rhs: Caked_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_PurgeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PurgeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .same(proto: "olderThan"),
    3: .same(proto: "cacheBudget"),
    4: .same(proto: "spaceBudget"),
    5: .same(proto: "gc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._entries) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._olderThan) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._cacheBudget) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._spaceBudget) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._gc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entries {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._olderThan {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cacheBudget {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._spaceBudget {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gc {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_PurgeRequest, rhs: Caked_PurgeRequest) -> Bool {
    if lhs._entries != rhs._entries {return false}
    if lhs._olderThan != rhs._olderThan {return false}
    if lhs._cacheBudget != rhs._cacheBudget {return false}
    if lhs._spaceBudget != rhs._spaceBudget {return false}
    if lhs._gc != rhs._gc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_ConfigureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "cpu"),
    3: .same(proto: "memory"),
    4: .same(proto: "diskSize"),
    5: .same(proto: "displayRefit"),
    6: .same(proto: "autostart"),
    7: .same(proto: "nested"),
    8: .same(proto: "mounts"),
    9: .same(proto: "netBridged"),
    10: .same(proto: "netSoftnet"),
    1120: .same(proto: "netSoftnetAllow"),
    12: .same(proto: "netHost"),
    13: .same(proto: "randomMAC"),
    24: .same(proto: "forwardedPort"),
    25: .same(proto: "resetForwardedPort"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._cpu) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._memory) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._diskSize) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._displayRefit) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._autostart) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._nested) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._mounts) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._netBridged) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._netSoftnet) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._netHost) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._randomMac) }()
      case 24: try { try decoder.decodeSingularStringField(value: &self._forwardedPort) }()
      case 25: try { try decoder.decodeSingularBoolField(value: &self._resetForwardedPort) }()
      case 1120: try { try decoder.decodeSingularStringField(value: &self._netSoftnetAllow) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._cpu {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memory {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._diskSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._displayRefit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._autostart {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._nested {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._mounts {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._netBridged {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._netSoftnet {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._netHost {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._randomMac {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._forwardedPort {
      try visitor.visitSingularStringField(value: v, fieldNumber: 24)
    } }()
    try { if let v = self._resetForwardedPort {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
    } }()
    try { if let v = self._netSoftnetAllow {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1120)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_ConfigureRequest, rhs: Caked_ConfigureRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._cpu != rhs._cpu {return false}
    if lhs._memory != rhs._memory {return false}
    if lhs._diskSize != rhs._diskSize {return false}
    if lhs._displayRefit != rhs._displayRefit {return false}
    if lhs._autostart != rhs._autostart {return false}
    if lhs._nested != rhs._nested {return false}
    if lhs._mounts != rhs._mounts {return false}
    if lhs._netBridged != rhs._netBridged {return false}
    if lhs._netSoftnet != rhs._netSoftnet {return false}
    if lhs._netSoftnetAllow != rhs._netSoftnetAllow {return false}
    if lhs._netHost != rhs._netHost {return false}
    if lhs._randomMac != rhs._randomMac {return false}
    if lhs._forwardedPort != rhs._forwardedPort {return false}
    if lhs._resetForwardedPort != rhs._resetForwardedPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .same(proto: "insecure"),
    4: .same(proto: "noValidate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.insecure) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.noValidate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if self.insecure != false {
      try visitor.visitSingularBoolField(value: self.insecure, fieldNumber: 3)
    }
    if self.noValidate != false {
      try visitor.visitSingularBoolField(value: self.noValidate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_LoginRequest, rhs: Caked_LoginRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.insecure != rhs.insecure {return false}
    if lhs.noValidate != rhs.noValidate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .output(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .output?: try {
      guard case .output(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Reply, rhs: Caked_Reply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
