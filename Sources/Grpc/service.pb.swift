// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Caked_Format: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case text // = 0
  case json // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .text
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .text
    case 1: self = .json
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .text: return 0
    case .json: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Caked_Format] = [
    .text,
    .json,
  ]

}

public enum Caked_RemoteCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case add // = 1
  case delete // = 2
  case list // = 3
  case info // = 4
  case pull // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .add
    case 2: self = .delete
    case 3: self = .list
    case 4: self = .info
    case 5: self = .pull
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .add: return 1
    case .delete: return 2
    case .list: return 3
    case .info: return 4
    case .pull: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Caked_RemoteCommand] = [
    .none,
    .add,
    .delete,
    .list,
    .info,
    .pull,
  ]

}

public enum Caked_VMState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case running // = 0
  case stopped // = 1
  case paused // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .running
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .running
    case 1: self = .stopped
    case 2: self = .paused
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .running: return 0
    case .stopped: return 1
    case .paused: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Caked_VMState] = [
    .running,
    .stopped,
    .paused,
  ]

}

public struct Caked_VMInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var disk: Int32 = 0

  public var size: Int32 = 0

  public var sizeOnDisk: Int32 = 0

  public var running: Bool = false

  public var state: Caked_VMState = .running

  public var source: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_DeleteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: Caked_Format = .text

  public var name: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_ListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vmonly: Bool = false

  public var format: Caked_Format = .text

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_ListReply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vms: [Caked_VMInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_StopRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_WaitIPRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var timeout: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_NetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: Caked_Format = .text

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_ImageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: Caked_RemoteCommand = .none

  public var name: String = String()

  public var format: Caked_Format = .text

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_RemoteRequestAdd: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_RemoteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: Caked_RemoteCommand = .none

  public var format: Caked_Format = .text

  public var request: Caked_RemoteRequest.OneOf_Request? = nil

  public var add: Caked_RemoteRequestAdd {
    get {
      if case .add(let v)? = request {return v}
      return Caked_RemoteRequestAdd()
    }
    set {request = .add(newValue)}
  }

  public var delete: String {
    get {
      if case .delete(let v)? = request {return v}
      return String()
    }
    set {request = .delete(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case add(Caked_RemoteRequestAdd)
    case delete(String)

  }

  public init() {}
}

public struct Caked_TemplateRequestAdd: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sourceName: String = String()

  public var templateName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_TemplateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: Caked_RemoteCommand = .none

  public var format: Caked_Format = .text

  public var request: Caked_TemplateRequest.OneOf_Request? = nil

  public var create: Caked_TemplateRequestAdd {
    get {
      if case .create(let v)? = request {return v}
      return Caked_TemplateRequestAdd()
    }
    set {request = .create(newValue)}
  }

  public var delete: String {
    get {
      if case .delete(let v)? = request {return v}
      return String()
    }
    set {request = .delete(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case create(Caked_TemplateRequestAdd)
    case delete(String)

  }

  public init() {}
}

public struct Caked_CakedCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: String = String()

  public var arguments: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_CommonBuildRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var cpu: Int32 {
    get {return _storage._cpu ?? 0}
    set {_uniqueStorage()._cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  public var hasCpu: Bool {return _storage._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  public mutating func clearCpu() {_uniqueStorage()._cpu = nil}

  public var memory: Int32 {
    get {return _storage._memory ?? 0}
    set {_uniqueStorage()._memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  public var hasMemory: Bool {return _storage._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  public mutating func clearMemory() {_uniqueStorage()._memory = nil}

  public var user: String {
    get {return _storage._user ?? String()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var password: String {
    get {return _storage._password ?? String()}
    set {_uniqueStorage()._password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  public var hasPassword: Bool {return _storage._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  public mutating func clearPassword() {_uniqueStorage()._password = nil}

  public var mainGroup: String {
    get {return _storage._mainGroup ?? String()}
    set {_uniqueStorage()._mainGroup = newValue}
  }
  /// Returns true if `mainGroup` has been explicitly set.
  public var hasMainGroup: Bool {return _storage._mainGroup != nil}
  /// Clears the value of `mainGroup`. Subsequent reads from it will return its default value.
  public mutating func clearMainGroup() {_uniqueStorage()._mainGroup = nil}

  public var sshPwAuth: Bool {
    get {return _storage._sshPwAuth ?? false}
    set {_uniqueStorage()._sshPwAuth = newValue}
  }
  /// Returns true if `sshPwAuth` has been explicitly set.
  public var hasSshPwAuth: Bool {return _storage._sshPwAuth != nil}
  /// Clears the value of `sshPwAuth`. Subsequent reads from it will return its default value.
  public mutating func clearSshPwAuth() {_uniqueStorage()._sshPwAuth = nil}

  public var image: String {
    get {return _storage._image ?? String()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var sshAuthorizedKey: Data {
    get {return _storage._sshAuthorizedKey ?? Data()}
    set {_uniqueStorage()._sshAuthorizedKey = newValue}
  }
  /// Returns true if `sshAuthorizedKey` has been explicitly set.
  public var hasSshAuthorizedKey: Bool {return _storage._sshAuthorizedKey != nil}
  /// Clears the value of `sshAuthorizedKey`. Subsequent reads from it will return its default value.
  public mutating func clearSshAuthorizedKey() {_uniqueStorage()._sshAuthorizedKey = nil}

  public var vendorData: Data {
    get {return _storage._vendorData ?? Data()}
    set {_uniqueStorage()._vendorData = newValue}
  }
  /// Returns true if `vendorData` has been explicitly set.
  public var hasVendorData: Bool {return _storage._vendorData != nil}
  /// Clears the value of `vendorData`. Subsequent reads from it will return its default value.
  public mutating func clearVendorData() {_uniqueStorage()._vendorData = nil}

  public var userData: Data {
    get {return _storage._userData ?? Data()}
    set {_uniqueStorage()._userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  public var hasUserData: Bool {return _storage._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  public mutating func clearUserData() {_uniqueStorage()._userData = nil}

  public var networkConfig: Data {
    get {return _storage._networkConfig ?? Data()}
    set {_uniqueStorage()._networkConfig = newValue}
  }
  /// Returns true if `networkConfig` has been explicitly set.
  public var hasNetworkConfig: Bool {return _storage._networkConfig != nil}
  /// Clears the value of `networkConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkConfig() {_uniqueStorage()._networkConfig = nil}

  public var diskSize: Int32 {
    get {return _storage._diskSize ?? 0}
    set {_uniqueStorage()._diskSize = newValue}
  }
  /// Returns true if `diskSize` has been explicitly set.
  public var hasDiskSize: Bool {return _storage._diskSize != nil}
  /// Clears the value of `diskSize`. Subsequent reads from it will return its default value.
  public mutating func clearDiskSize() {_uniqueStorage()._diskSize = nil}

  public var autostart: Bool {
    get {return _storage._autostart ?? false}
    set {_uniqueStorage()._autostart = newValue}
  }
  /// Returns true if `autostart` has been explicitly set.
  public var hasAutostart: Bool {return _storage._autostart != nil}
  /// Clears the value of `autostart`. Subsequent reads from it will return its default value.
  public mutating func clearAutostart() {_uniqueStorage()._autostart = nil}

  public var nested: Bool {
    get {return _storage._nested ?? false}
    set {_uniqueStorage()._nested = newValue}
  }
  /// Returns true if `nested` has been explicitly set.
  public var hasNested: Bool {return _storage._nested != nil}
  /// Clears the value of `nested`. Subsequent reads from it will return its default value.
  public mutating func clearNested() {_uniqueStorage()._nested = nil}

  public var forwardedPort: String {
    get {return _storage._forwardedPort ?? String()}
    set {_uniqueStorage()._forwardedPort = newValue}
  }
  /// Returns true if `forwardedPort` has been explicitly set.
  public var hasForwardedPort: Bool {return _storage._forwardedPort != nil}
  /// Clears the value of `forwardedPort`. Subsequent reads from it will return its default value.
  public mutating func clearForwardedPort() {_uniqueStorage()._forwardedPort = nil}

  public var mounts: String {
    get {return _storage._mounts ?? String()}
    set {_uniqueStorage()._mounts = newValue}
  }
  /// Returns true if `mounts` has been explicitly set.
  public var hasMounts: Bool {return _storage._mounts != nil}
  /// Clears the value of `mounts`. Subsequent reads from it will return its default value.
  public mutating func clearMounts() {_uniqueStorage()._mounts = nil}

  public var networks: String {
    get {return _storage._networks ?? String()}
    set {_uniqueStorage()._networks = newValue}
  }
  /// Returns true if `networks` has been explicitly set.
  public var hasNetworks: Bool {return _storage._networks != nil}
  /// Clears the value of `networks`. Subsequent reads from it will return its default value.
  public mutating func clearNetworks() {_uniqueStorage()._networks = nil}

  public var sockets: String {
    get {return _storage._sockets ?? String()}
    set {_uniqueStorage()._sockets = newValue}
  }
  /// Returns true if `sockets` has been explicitly set.
  public var hasSockets: Bool {return _storage._sockets != nil}
  /// Clears the value of `sockets`. Subsequent reads from it will return its default value.
  public mutating func clearSockets() {_uniqueStorage()._sockets = nil}

  public var console: String {
    get {return _storage._console ?? String()}
    set {_uniqueStorage()._console = newValue}
  }
  /// Returns true if `console` has been explicitly set.
  public var hasConsole: Bool {return _storage._console != nil}
  /// Clears the value of `console`. Subsequent reads from it will return its default value.
  public mutating func clearConsole() {_uniqueStorage()._console = nil}

  public var attachedDisks: String {
    get {return _storage._attachedDisks ?? String()}
    set {_uniqueStorage()._attachedDisks = newValue}
  }
  /// Returns true if `attachedDisks` has been explicitly set.
  public var hasAttachedDisks: Bool {return _storage._attachedDisks != nil}
  /// Clears the value of `attachedDisks`. Subsequent reads from it will return its default value.
  public mutating func clearAttachedDisks() {_uniqueStorage()._attachedDisks = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Caked_BuildRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: Caked_CommonBuildRequest {
    get {return _options ?? Caked_CommonBuildRequest()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Caked_CommonBuildRequest? = nil
}

public struct Caked_LaunchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: Caked_CommonBuildRequest {
    get {return _options ?? Caked_CommonBuildRequest()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var waitIptimeout: Int32 {
    get {return _waitIptimeout ?? 0}
    set {_waitIptimeout = newValue}
  }
  /// Returns true if `waitIptimeout` has been explicitly set.
  public var hasWaitIptimeout: Bool {return self._waitIptimeout != nil}
  /// Clears the value of `waitIptimeout`. Subsequent reads from it will return its default value.
  public mutating func clearWaitIptimeout() {self._waitIptimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Caked_CommonBuildRequest? = nil
  fileprivate var _waitIptimeout: Int32? = nil
}

public struct Caked_StartRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var waitIptimeout: Int32 {
    get {return _waitIptimeout ?? 0}
    set {_waitIptimeout = newValue}
  }
  /// Returns true if `waitIptimeout` has been explicitly set.
  public var hasWaitIptimeout: Bool {return self._waitIptimeout != nil}
  /// Clears the value of `waitIptimeout`. Subsequent reads from it will return its default value.
  public mutating func clearWaitIptimeout() {self._waitIptimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _waitIptimeout: Int32? = nil
}

public struct Caked_Error: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_PurgeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entries: String {
    get {return _entries ?? String()}
    set {_entries = newValue}
  }
  /// Returns true if `entries` has been explicitly set.
  public var hasEntries: Bool {return self._entries != nil}
  /// Clears the value of `entries`. Subsequent reads from it will return its default value.
  public mutating func clearEntries() {self._entries = nil}

  public var olderThan: Int32 {
    get {return _olderThan ?? 0}
    set {_olderThan = newValue}
  }
  /// Returns true if `olderThan` has been explicitly set.
  public var hasOlderThan: Bool {return self._olderThan != nil}
  /// Clears the value of `olderThan`. Subsequent reads from it will return its default value.
  public mutating func clearOlderThan() {self._olderThan = nil}

  public var cacheBudget: Int32 {
    get {return _cacheBudget ?? 0}
    set {_cacheBudget = newValue}
  }
  /// Returns true if `cacheBudget` has been explicitly set.
  public var hasCacheBudget: Bool {return self._cacheBudget != nil}
  /// Clears the value of `cacheBudget`. Subsequent reads from it will return its default value.
  public mutating func clearCacheBudget() {self._cacheBudget = nil}

  public var spaceBudget: Int32 {
    get {return _spaceBudget ?? 0}
    set {_spaceBudget = newValue}
  }
  /// Returns true if `spaceBudget` has been explicitly set.
  public var hasSpaceBudget: Bool {return self._spaceBudget != nil}
  /// Clears the value of `spaceBudget`. Subsequent reads from it will return its default value.
  public mutating func clearSpaceBudget() {self._spaceBudget = nil}

  public var gc: Bool {
    get {return _gc ?? false}
    set {_gc = newValue}
  }
  /// Returns true if `gc` has been explicitly set.
  public var hasGc: Bool {return self._gc != nil}
  /// Clears the value of `gc`. Subsequent reads from it will return its default value.
  public mutating func clearGc() {self._gc = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entries: String? = nil
  fileprivate var _olderThan: Int32? = nil
  fileprivate var _cacheBudget: Int32? = nil
  fileprivate var _spaceBudget: Int32? = nil
  fileprivate var _gc: Bool? = nil
}

public struct Caked_ConfigureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var cpu: Int32 {
    get {return _cpu ?? 0}
    set {_cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  public var hasCpu: Bool {return self._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  public mutating func clearCpu() {self._cpu = nil}

  public var memory: Int32 {
    get {return _memory ?? 0}
    set {_memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  public var hasMemory: Bool {return self._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  public mutating func clearMemory() {self._memory = nil}

  public var diskSize: Int32 {
    get {return _diskSize ?? 0}
    set {_diskSize = newValue}
  }
  /// Returns true if `diskSize` has been explicitly set.
  public var hasDiskSize: Bool {return self._diskSize != nil}
  /// Clears the value of `diskSize`. Subsequent reads from it will return its default value.
  public mutating func clearDiskSize() {self._diskSize = nil}

  public var displayRefit: Bool {
    get {return _displayRefit ?? false}
    set {_displayRefit = newValue}
  }
  /// Returns true if `displayRefit` has been explicitly set.
  public var hasDisplayRefit: Bool {return self._displayRefit != nil}
  /// Clears the value of `displayRefit`. Subsequent reads from it will return its default value.
  public mutating func clearDisplayRefit() {self._displayRefit = nil}

  public var autostart: Bool {
    get {return _autostart ?? false}
    set {_autostart = newValue}
  }
  /// Returns true if `autostart` has been explicitly set.
  public var hasAutostart: Bool {return self._autostart != nil}
  /// Clears the value of `autostart`. Subsequent reads from it will return its default value.
  public mutating func clearAutostart() {self._autostart = nil}

  public var nested: Bool {
    get {return _nested ?? false}
    set {_nested = newValue}
  }
  /// Returns true if `nested` has been explicitly set.
  public var hasNested: Bool {return self._nested != nil}
  /// Clears the value of `nested`. Subsequent reads from it will return its default value.
  public mutating func clearNested() {self._nested = nil}

  public var mounts: String {
    get {return _mounts ?? String()}
    set {_mounts = newValue}
  }
  /// Returns true if `mounts` has been explicitly set.
  public var hasMounts: Bool {return self._mounts != nil}
  /// Clears the value of `mounts`. Subsequent reads from it will return its default value.
  public mutating func clearMounts() {self._mounts = nil}

  public var networks: String {
    get {return _networks ?? String()}
    set {_networks = newValue}
  }
  /// Returns true if `networks` has been explicitly set.
  public var hasNetworks: Bool {return self._networks != nil}
  /// Clears the value of `networks`. Subsequent reads from it will return its default value.
  public mutating func clearNetworks() {self._networks = nil}

  public var sockets: String {
    get {return _sockets ?? String()}
    set {_sockets = newValue}
  }
  /// Returns true if `sockets` has been explicitly set.
  public var hasSockets: Bool {return self._sockets != nil}
  /// Clears the value of `sockets`. Subsequent reads from it will return its default value.
  public mutating func clearSockets() {self._sockets = nil}

  public var console: String {
    get {return _console ?? String()}
    set {_console = newValue}
  }
  /// Returns true if `console` has been explicitly set.
  public var hasConsole: Bool {return self._console != nil}
  /// Clears the value of `console`. Subsequent reads from it will return its default value.
  public mutating func clearConsole() {self._console = nil}

  public var randomMac: Bool {
    get {return _randomMac ?? false}
    set {_randomMac = newValue}
  }
  /// Returns true if `randomMac` has been explicitly set.
  public var hasRandomMac: Bool {return self._randomMac != nil}
  /// Clears the value of `randomMac`. Subsequent reads from it will return its default value.
  public mutating func clearRandomMac() {self._randomMac = nil}

  public var forwardedPort: String {
    get {return _forwardedPort ?? String()}
    set {_forwardedPort = newValue}
  }
  /// Returns true if `forwardedPort` has been explicitly set.
  public var hasForwardedPort: Bool {return self._forwardedPort != nil}
  /// Clears the value of `forwardedPort`. Subsequent reads from it will return its default value.
  public mutating func clearForwardedPort() {self._forwardedPort = nil}

  public var attachedDisks: String {
    get {return _attachedDisks ?? String()}
    set {_attachedDisks = newValue}
  }
  /// Returns true if `attachedDisks` has been explicitly set.
  public var hasAttachedDisks: Bool {return self._attachedDisks != nil}
  /// Clears the value of `attachedDisks`. Subsequent reads from it will return its default value.
  public mutating func clearAttachedDisks() {self._attachedDisks = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cpu: Int32? = nil
  fileprivate var _memory: Int32? = nil
  fileprivate var _diskSize: Int32? = nil
  fileprivate var _displayRefit: Bool? = nil
  fileprivate var _autostart: Bool? = nil
  fileprivate var _nested: Bool? = nil
  fileprivate var _mounts: String? = nil
  fileprivate var _networks: String? = nil
  fileprivate var _sockets: String? = nil
  fileprivate var _console: String? = nil
  fileprivate var _randomMac: Bool? = nil
  fileprivate var _forwardedPort: String? = nil
  fileprivate var _attachedDisks: String? = nil
}

public struct Caked_LogoutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_LoginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var username: String = String()

  public var password: String = String()

  public var insecure: Bool = false

  public var noValidate: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_Reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Caked_Reply.OneOf_Response? = nil

  public var error: Caked_Error {
    get {
      if case .error(let v)? = response {return v}
      return Caked_Error()
    }
    set {response = .error(newValue)}
  }

  public var output: String {
    get {
      if case .output(let v)? = response {return v}
      return String()
    }
    set {response = .output(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case error(Caked_Error)
    case output(String)

  }

  public init() {}
}

public struct Caked_InfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_InfoReply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var uptime: UInt64 {
    get {return _uptime ?? 0}
    set {_uptime = newValue}
  }
  /// Returns true if `uptime` has been explicitly set.
  public var hasUptime: Bool {return self._uptime != nil}
  /// Clears the value of `uptime`. Subsequent reads from it will return its default value.
  public mutating func clearUptime() {self._uptime = nil}

  public var memory: Caked_InfoReply.MemoryInfo {
    get {return _memory ?? Caked_InfoReply.MemoryInfo()}
    set {_memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  public var hasMemory: Bool {return self._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  public mutating func clearMemory() {self._memory = nil}

  public var cpuCount: Int32 = 0

  public var ipaddresses: [String] = []

  public var osname: String = String()

  public var hostname: String {
    get {return _hostname ?? String()}
    set {_hostname = newValue}
  }
  /// Returns true if `hostname` has been explicitly set.
  public var hasHostname: Bool {return self._hostname != nil}
  /// Clears the value of `hostname`. Subsequent reads from it will return its default value.
  public mutating func clearHostname() {self._hostname = nil}

  public var release: String {
    get {return _release ?? String()}
    set {_release = newValue}
  }
  /// Returns true if `release` has been explicitly set.
  public var hasRelease: Bool {return self._release != nil}
  /// Clears the value of `release`. Subsequent reads from it will return its default value.
  public mutating func clearRelease() {self._release = nil}

  public var status: String = String()

  public var mounts: [String] = []

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct MemoryInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var total: UInt64 = 0

    public var free: UInt64 {
      get {return _free ?? 0}
      set {_free = newValue}
    }
    /// Returns true if `free` has been explicitly set.
    public var hasFree: Bool {return self._free != nil}
    /// Clears the value of `free`. Subsequent reads from it will return its default value.
    public mutating func clearFree() {self._free = nil}

    public var used: UInt64 {
      get {return _used ?? 0}
      set {_used = newValue}
    }
    /// Returns true if `used` has been explicitly set.
    public var hasUsed: Bool {return self._used != nil}
    /// Clears the value of `used`. Subsequent reads from it will return its default value.
    public mutating func clearUsed() {self._used = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _free: UInt64? = nil
    fileprivate var _used: UInt64? = nil
  }

  public init() {}

  fileprivate var _version: String? = nil
  fileprivate var _uptime: UInt64? = nil
  fileprivate var _memory: Caked_InfoReply.MemoryInfo? = nil
  fileprivate var _hostname: String? = nil
  fileprivate var _release: String? = nil
}

public struct Caked_Command: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: String = String()

  public var args: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_ExecuteCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var execute: Caked_ExecuteCommand.OneOf_Execute? = nil

  public var command: Caked_Command {
    get {
      if case .command(let v)? = execute {return v}
      return Caked_Command()
    }
    set {execute = .command(newValue)}
  }

  public var shell: Bool {
    get {
      if case .shell(let v)? = execute {return v}
      return false
    }
    set {execute = .shell(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Execute: Equatable, Sendable {
    case command(Caked_Command)
    case shell(Bool)

  }

  public init() {}
}

public struct Caked_TerminalSize: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rows: Int32 = 0

  public var cols: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_ExecuteRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Caked_ExecuteRequest.OneOf_Request? = nil

  public var command: Caked_ExecuteCommand {
    get {
      if case .command(let v)? = request {return v}
      return Caked_ExecuteCommand()
    }
    set {request = .command(newValue)}
  }

  public var input: Data {
    get {
      if case .input(let v)? = request {return v}
      return Data()
    }
    set {request = .input(newValue)}
  }

  public var size: Caked_TerminalSize {
    get {
      if case .size(let v)? = request {return v}
      return Caked_TerminalSize()
    }
    set {request = .size(newValue)}
  }

  public var eof: Bool {
    get {
      if case .eof(let v)? = request {return v}
      return false
    }
    set {request = .eof(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, @unchecked Sendable {
    case command(Caked_ExecuteCommand)
    case input(Data)
    case size(Caked_TerminalSize)
    case eof(Bool)

  }

  public init() {}
}

public struct Caked_ExecuteResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Caked_ExecuteResponse.OneOf_Response? = nil

  public var exitCode: Int32 {
    get {
      if case .exitCode(let v)? = response {return v}
      return 0
    }
    set {response = .exitCode(newValue)}
  }

  public var stdout: Data {
    get {
      if case .stdout(let v)? = response {return v}
      return Data()
    }
    set {response = .stdout(newValue)}
  }

  public var stderr: Data {
    get {
      if case .stderr(let v)? = response {return v}
      return Data()
    }
    set {response = .stderr(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, @unchecked Sendable {
    case exitCode(Int32)
    case stdout(Data)
    case stderr(Data)

  }

  public init() {}
}

public struct Caked_RenameRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var oldname: String = String()

  public var newname: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_MountVirtioFS: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: String = String()

  public var target: String {
    get {return _target ?? String()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {self._target = nil}

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var uid: Int32 {
    get {return _uid ?? 0}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  public var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  public mutating func clearUid() {self._uid = nil}

  public var gid: Int32 {
    get {return _gid ?? 0}
    set {_gid = newValue}
  }
  /// Returns true if `gid` has been explicitly set.
  public var hasGid: Bool {return self._gid != nil}
  /// Clears the value of `gid`. Subsequent reads from it will return its default value.
  public mutating func clearGid() {self._gid = nil}

  public var readonly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _target: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _uid: Int32? = nil
  fileprivate var _gid: Int32? = nil
}

public struct Caked_MountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: Caked_RemoteCommand = .none

  public var name: String = String()

  public var format: Caked_Format = .text

  public var mounts: [Caked_MountVirtioFS] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Caked_MountVirtioFSReply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var response: Caked_MountVirtioFSReply.OneOf_Response? = nil

  public var error: String {
    get {
      if case .error(let v)? = response {return v}
      return String()
    }
    set {response = .error(newValue)}
  }

  public var success: Bool {
    get {
      if case .success(let v)? = response {return v}
      return false
    }
    set {response = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case error(String)
    case success(Bool)

  }

  public init() {}
}

public struct Caked_MountReply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mounts: [Caked_MountVirtioFSReply] = []

  public var response: Caked_MountReply.OneOf_Response? = nil

  public var error: String {
    get {
      if case .error(let v)? = response {return v}
      return String()
    }
    set {response = .error(newValue)}
  }

  public var success: Bool {
    get {
      if case .success(let v)? = response {return v}
      return false
    }
    set {response = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case error(String)
    case success(Bool)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "caked"

extension Caked_Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "text"),
    1: .same(proto: "json"),
  ]
}

extension Caked_RemoteCommand: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "add"),
    2: .same(proto: "delete"),
    3: .same(proto: "list"),
    4: .same(proto: "info"),
    5: .same(proto: "pull"),
  ]
}

extension Caked_VMState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "running"),
    1: .same(proto: "stopped"),
    2: .same(proto: "paused"),
  ]
}

extension Caked_VMInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VMInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Disk"),
    3: .same(proto: "Size"),
    4: .same(proto: "SizeOnDisk"),
    5: .same(proto: "Running"),
    6: .same(proto: "State"),
    7: .same(proto: "Source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.disk) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.sizeOnDisk) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.running) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.disk != 0 {
      try visitor.visitSingularInt32Field(value: self.disk, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 3)
    }
    if self.sizeOnDisk != 0 {
      try visitor.visitSingularInt32Field(value: self.sizeOnDisk, fieldNumber: 4)
    }
    if self.running != false {
      try visitor.visitSingularBoolField(value: self.running, fieldNumber: 5)
    }
    if self.state != .running {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_VMInfo, rhs: Caked_VMInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.disk != rhs.disk {return false}
    if lhs.size != rhs.size {return false}
    if lhs.sizeOnDisk != rhs.sizeOnDisk {return false}
    if lhs.running != rhs.running {return false}
    if lhs.state != rhs.state {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_DeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.format != .text {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitRepeatedStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_DeleteRequest, rhs: Caked_DeleteRequest) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_ListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vmonly"),
    2: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.vmonly) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vmonly != false {
      try visitor.visitSingularBoolField(value: self.vmonly, fieldNumber: 1)
    }
    if self.format != .text {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_ListRequest, rhs: Caked_ListRequest) -> Bool {
    if lhs.vmonly != rhs.vmonly {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_ListReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.vms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_ListReply, rhs: Caked_ListReply) -> Bool {
    if lhs.vms != rhs.vms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_StopRequest, rhs: Caked_StopRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_WaitIPRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitIPRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt32Field(value: self.timeout, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_WaitIPRequest, rhs: Caked_WaitIPRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_NetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.format != .text {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_NetworkRequest, rhs: Caked_NetworkRequest) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_ImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "name"),
    3: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.format != .text {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_ImageRequest, rhs: Caked_ImageRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.name != rhs.name {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_RemoteRequestAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteRequestAdd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_RemoteRequestAdd, rhs: Caked_RemoteRequestAdd) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_RemoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "format"),
    3: .same(proto: "add"),
    4: .same(proto: "delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 3: try {
        var v: Caked_RemoteRequestAdd?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .add(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .add(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.request != nil {try decoder.handleConflictingOneOf()}
          self.request = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if self.format != .text {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    switch self.request {
    case .add?: try {
      guard case .add(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_RemoteRequest, rhs: Caked_RemoteRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.format != rhs.format {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_TemplateRequestAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TemplateRequestAdd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sourceName"),
    2: .same(proto: "templateName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.templateName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceName, fieldNumber: 1)
    }
    if !self.templateName.isEmpty {
      try visitor.visitSingularStringField(value: self.templateName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_TemplateRequestAdd, rhs: Caked_TemplateRequestAdd) -> Bool {
    if lhs.sourceName != rhs.sourceName {return false}
    if lhs.templateName != rhs.templateName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_TemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "format"),
    3: .same(proto: "create"),
    4: .same(proto: "delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 3: try {
        var v: Caked_TemplateRequestAdd?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .create(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.request != nil {try decoder.handleConflictingOneOf()}
          self.request = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if self.format != .text {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    switch self.request {
    case .create?: try {
      guard case .create(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_TemplateRequest, rhs: Caked_TemplateRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.format != rhs.format {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_CakedCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CakedCommandRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "arguments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_CakedCommandRequest, rhs: Caked_CakedCommandRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_CommonBuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommonBuildRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "cpu"),
    3: .same(proto: "memory"),
    4: .same(proto: "user"),
    22: .same(proto: "password"),
    5: .same(proto: "mainGroup"),
    6: .same(proto: "sshPwAuth"),
    7: .same(proto: "image"),
    8: .same(proto: "sshAuthorizedKey"),
    9: .same(proto: "vendorData"),
    10: .same(proto: "userData"),
    11: .same(proto: "networkConfig"),
    12: .same(proto: "diskSize"),
    13: .same(proto: "autostart"),
    14: .same(proto: "nested"),
    15: .same(proto: "forwardedPort"),
    16: .same(proto: "mounts"),
    17: .same(proto: "networks"),
    18: .same(proto: "sockets"),
    19: .same(proto: "console"),
    20: .same(proto: "attachedDisks"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _cpu: Int32? = nil
    var _memory: Int32? = nil
    var _user: String? = nil
    var _password: String? = nil
    var _mainGroup: String? = nil
    var _sshPwAuth: Bool? = nil
    var _image: String? = nil
    var _sshAuthorizedKey: Data? = nil
    var _vendorData: Data? = nil
    var _userData: Data? = nil
    var _networkConfig: Data? = nil
    var _diskSize: Int32? = nil
    var _autostart: Bool? = nil
    var _nested: Bool? = nil
    var _forwardedPort: String? = nil
    var _mounts: String? = nil
    var _networks: String? = nil
    var _sockets: String? = nil
    var _console: String? = nil
    var _attachedDisks: String? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _cpu = source._cpu
      _memory = source._memory
      _user = source._user
      _password = source._password
      _mainGroup = source._mainGroup
      _sshPwAuth = source._sshPwAuth
      _image = source._image
      _sshAuthorizedKey = source._sshAuthorizedKey
      _vendorData = source._vendorData
      _userData = source._userData
      _networkConfig = source._networkConfig
      _diskSize = source._diskSize
      _autostart = source._autostart
      _nested = source._nested
      _forwardedPort = source._forwardedPort
      _mounts = source._mounts
      _networks = source._networks
      _sockets = source._sockets
      _console = source._console
      _attachedDisks = source._attachedDisks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._cpu) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._memory) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._mainGroup) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._sshPwAuth) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._image) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._sshAuthorizedKey) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._vendorData) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._userData) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._networkConfig) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._diskSize) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._autostart) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._nested) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._forwardedPort) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._mounts) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._networks) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._sockets) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._console) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._attachedDisks) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._password) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._cpu {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memory {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._mainGroup {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sshPwAuth {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sshAuthorizedKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._vendorData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._userData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._networkConfig {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._diskSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._autostart {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._nested {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._forwardedPort {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._mounts {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._networks {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._sockets {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._console {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._attachedDisks {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._password {
        try visitor.visitSingularStringField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_CommonBuildRequest, rhs: Caked_CommonBuildRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._password != rhs_storage._password {return false}
        if _storage._mainGroup != rhs_storage._mainGroup {return false}
        if _storage._sshPwAuth != rhs_storage._sshPwAuth {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._sshAuthorizedKey != rhs_storage._sshAuthorizedKey {return false}
        if _storage._vendorData != rhs_storage._vendorData {return false}
        if _storage._userData != rhs_storage._userData {return false}
        if _storage._networkConfig != rhs_storage._networkConfig {return false}
        if _storage._diskSize != rhs_storage._diskSize {return false}
        if _storage._autostart != rhs_storage._autostart {return false}
        if _storage._nested != rhs_storage._nested {return false}
        if _storage._forwardedPort != rhs_storage._forwardedPort {return false}
        if _storage._mounts != rhs_storage._mounts {return false}
        if _storage._networks != rhs_storage._networks {return false}
        if _storage._sockets != rhs_storage._sockets {return false}
        if _storage._console != rhs_storage._console {return false}
        if _storage._attachedDisks != rhs_storage._attachedDisks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_BuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_BuildRequest, rhs: Caked_BuildRequest) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_LaunchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LaunchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
    2: .same(proto: "waitIPTimeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._waitIptimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._waitIptimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_LaunchRequest, rhs: Caked_LaunchRequest) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs._waitIptimeout != rhs._waitIptimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_StartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "waitIPTimeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._waitIptimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._waitIptimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_StartRequest, rhs: Caked_StartRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._waitIptimeout != rhs._waitIptimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Error, rhs: Caked_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_PurgeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PurgeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .same(proto: "olderThan"),
    3: .same(proto: "cacheBudget"),
    4: .same(proto: "spaceBudget"),
    5: .same(proto: "gc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._entries) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._olderThan) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._cacheBudget) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._spaceBudget) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._gc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entries {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._olderThan {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cacheBudget {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._spaceBudget {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gc {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_PurgeRequest, rhs: Caked_PurgeRequest) -> Bool {
    if lhs._entries != rhs._entries {return false}
    if lhs._olderThan != rhs._olderThan {return false}
    if lhs._cacheBudget != rhs._cacheBudget {return false}
    if lhs._spaceBudget != rhs._spaceBudget {return false}
    if lhs._gc != rhs._gc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_ConfigureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "cpu"),
    3: .same(proto: "memory"),
    4: .same(proto: "diskSize"),
    5: .same(proto: "displayRefit"),
    6: .same(proto: "autostart"),
    7: .same(proto: "nested"),
    8: .same(proto: "mounts"),
    9: .same(proto: "networks"),
    10: .same(proto: "sockets"),
    11: .same(proto: "console"),
    12: .same(proto: "randomMAC"),
    13: .same(proto: "forwardedPort"),
    14: .same(proto: "attachedDisks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._cpu) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._memory) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._diskSize) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._displayRefit) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._autostart) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._nested) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._mounts) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._networks) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._sockets) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._console) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._randomMac) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._forwardedPort) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._attachedDisks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._cpu {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memory {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._diskSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._displayRefit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._autostart {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._nested {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._mounts {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._networks {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._sockets {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._console {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._randomMac {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._forwardedPort {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._attachedDisks {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_ConfigureRequest, rhs: Caked_ConfigureRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._cpu != rhs._cpu {return false}
    if lhs._memory != rhs._memory {return false}
    if lhs._diskSize != rhs._diskSize {return false}
    if lhs._displayRefit != rhs._displayRefit {return false}
    if lhs._autostart != rhs._autostart {return false}
    if lhs._nested != rhs._nested {return false}
    if lhs._mounts != rhs._mounts {return false}
    if lhs._networks != rhs._networks {return false}
    if lhs._sockets != rhs._sockets {return false}
    if lhs._console != rhs._console {return false}
    if lhs._randomMac != rhs._randomMac {return false}
    if lhs._forwardedPort != rhs._forwardedPort {return false}
    if lhs._attachedDisks != rhs._attachedDisks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_LogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_LogoutRequest, rhs: Caked_LogoutRequest) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "username"),
    3: .same(proto: "password"),
    4: .same(proto: "insecure"),
    5: .same(proto: "noValidate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.insecure) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.noValidate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if self.insecure != false {
      try visitor.visitSingularBoolField(value: self.insecure, fieldNumber: 4)
    }
    if self.noValidate != false {
      try visitor.visitSingularBoolField(value: self.noValidate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_LoginRequest, rhs: Caked_LoginRequest) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.insecure != rhs.insecure {return false}
    if lhs.noValidate != rhs.noValidate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .output(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .output?: try {
      guard case .output(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Reply, rhs: Caked_Reply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_InfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_InfoRequest, rhs: Caked_InfoRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_InfoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "uptime"),
    3: .same(proto: "memory"),
    4: .same(proto: "cpuCount"),
    5: .same(proto: "ipaddresses"),
    6: .same(proto: "osname"),
    7: .same(proto: "hostname"),
    8: .same(proto: "release"),
    9: .same(proto: "status"),
    10: .same(proto: "mounts"),
    11: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._version) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._uptime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memory) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.cpuCount) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.ipaddresses) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.osname) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._hostname) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._release) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.mounts) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uptime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.cpuCount != 0 {
      try visitor.visitSingularInt32Field(value: self.cpuCount, fieldNumber: 4)
    }
    if !self.ipaddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipaddresses, fieldNumber: 5)
    }
    if !self.osname.isEmpty {
      try visitor.visitSingularStringField(value: self.osname, fieldNumber: 6)
    }
    try { if let v = self._hostname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._release {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 9)
    }
    if !self.mounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mounts, fieldNumber: 10)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_InfoReply, rhs: Caked_InfoReply) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._uptime != rhs._uptime {return false}
    if lhs._memory != rhs._memory {return false}
    if lhs.cpuCount != rhs.cpuCount {return false}
    if lhs.ipaddresses != rhs.ipaddresses {return false}
    if lhs.osname != rhs.osname {return false}
    if lhs._hostname != rhs._hostname {return false}
    if lhs._release != rhs._release {return false}
    if lhs.status != rhs.status {return false}
    if lhs.mounts != rhs.mounts {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_InfoReply.MemoryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_InfoReply.protoMessageName + ".MemoryInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "free"),
    3: .same(proto: "used"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._free) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._used) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.total != 0 {
      try visitor.visitSingularUInt64Field(value: self.total, fieldNumber: 1)
    }
    try { if let v = self._free {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._used {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_InfoReply.MemoryInfo, rhs: Caked_InfoReply.MemoryInfo) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs._free != rhs._free {return false}
    if lhs._used != rhs._used {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Command, rhs: Caked_Command) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_ExecuteCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "shell"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Command?
        var hadOneofValue = false
        if let current = self.execute {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.execute = .command(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.execute != nil {try decoder.handleConflictingOneOf()}
          self.execute = .shell(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.execute {
    case .command?: try {
      guard case .command(let v)? = self.execute else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .shell?: try {
      guard case .shell(let v)? = self.execute else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_ExecuteCommand, rhs: Caked_ExecuteCommand) -> Bool {
    if lhs.execute != rhs.execute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_TerminalSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalSize"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rows"),
    2: .same(proto: "cols"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rows) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.cols) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rows != 0 {
      try visitor.visitSingularInt32Field(value: self.rows, fieldNumber: 1)
    }
    if self.cols != 0 {
      try visitor.visitSingularInt32Field(value: self.cols, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_TerminalSize, rhs: Caked_TerminalSize) -> Bool {
    if lhs.rows != rhs.rows {return false}
    if lhs.cols != rhs.cols {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_ExecuteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "input"),
    3: .same(proto: "size"),
    4: .same(proto: "eof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_ExecuteCommand?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .command(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.request != nil {try decoder.handleConflictingOneOf()}
          self.request = .input(v)
        }
      }()
      case 3: try {
        var v: Caked_TerminalSize?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .size(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .size(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.request != nil {try decoder.handleConflictingOneOf()}
          self.request = .eof(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .command?: try {
      guard case .command(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .input?: try {
      guard case .input(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .size?: try {
      guard case .size(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .eof?: try {
      guard case .eof(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_ExecuteRequest, rhs: Caked_ExecuteRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_ExecuteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exitCode"),
    2: .same(proto: "stdout"),
    3: .same(proto: "stderr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .exitCode(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .stdout(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .stderr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .exitCode?: try {
      guard case .exitCode(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .stdout?: try {
      guard case .stdout(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .stderr?: try {
      guard case .stderr(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_ExecuteResponse, rhs: Caked_ExecuteResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_RenameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenameRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oldname"),
    2: .same(proto: "newname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oldname) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oldname.isEmpty {
      try visitor.visitSingularStringField(value: self.oldname, fieldNumber: 1)
    }
    if !self.newname.isEmpty {
      try visitor.visitSingularStringField(value: self.newname, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_RenameRequest, rhs: Caked_RenameRequest) -> Bool {
    if lhs.oldname != rhs.oldname {return false}
    if lhs.newname != rhs.newname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_MountVirtioFS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MountVirtioFS"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "target"),
    3: .same(proto: "name"),
    4: .same(proto: "uid"),
    5: .same(proto: "gid"),
    6: .same(proto: "readonly"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._uid) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._gid) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.readonly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    try { if let v = self._target {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._uid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if self.readonly != false {
      try visitor.visitSingularBoolField(value: self.readonly, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_MountVirtioFS, rhs: Caked_MountVirtioFS) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._target != rhs._target {return false}
    if lhs._name != rhs._name {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._gid != rhs._gid {return false}
    if lhs.readonly != rhs.readonly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_MountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "name"),
    3: .same(proto: "format"),
    4: .same(proto: "mounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.mounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.format != .text {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 3)
    }
    if !self.mounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mounts, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_MountRequest, rhs: Caked_MountRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.name != rhs.name {return false}
    if lhs.format != rhs.format {return false}
    if lhs.mounts != rhs.mounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_MountVirtioFSReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MountVirtioFSReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_MountVirtioFSReply, rhs: Caked_MountVirtioFSReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_MountReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MountReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mounts"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mounts) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mounts, fieldNumber: 1)
    }
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_MountReply, rhs: Caked_MountReply) -> Bool {
    if lhs.mounts != rhs.mounts {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
