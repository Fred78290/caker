// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Caked_Caked: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct PingRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var message: String = String()

    public var timestamp: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct CurrentStatusRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var frequency: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct VMRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct CommonBuildRequest: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String {
        get {_storage._name}
        set {_uniqueStorage()._name = newValue}
      }

      public var cpu: Int32 {
        get {_storage._cpu ?? 0}
        set {_uniqueStorage()._cpu = newValue}
      }
      /// Returns true if `cpu` has been explicitly set.
      public var hasCpu: Bool {_storage._cpu != nil}
      /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
      public mutating func clearCpu() {_uniqueStorage()._cpu = nil}

      public var memory: Int32 {
        get {_storage._memory ?? 0}
        set {_uniqueStorage()._memory = newValue}
      }
      /// Returns true if `memory` has been explicitly set.
      public var hasMemory: Bool {_storage._memory != nil}
      /// Clears the value of `memory`. Subsequent reads from it will return its default value.
      public mutating func clearMemory() {_uniqueStorage()._memory = nil}

      public var user: String {
        get {_storage._user ?? String()}
        set {_uniqueStorage()._user = newValue}
      }
      /// Returns true if `user` has been explicitly set.
      public var hasUser: Bool {_storage._user != nil}
      /// Clears the value of `user`. Subsequent reads from it will return its default value.
      public mutating func clearUser() {_uniqueStorage()._user = nil}

      public var password: String {
        get {_storage._password ?? String()}
        set {_uniqueStorage()._password = newValue}
      }
      /// Returns true if `password` has been explicitly set.
      public var hasPassword: Bool {_storage._password != nil}
      /// Clears the value of `password`. Subsequent reads from it will return its default value.
      public mutating func clearPassword() {_uniqueStorage()._password = nil}

      public var mainGroup: String {
        get {_storage._mainGroup ?? String()}
        set {_uniqueStorage()._mainGroup = newValue}
      }
      /// Returns true if `mainGroup` has been explicitly set.
      public var hasMainGroup: Bool {_storage._mainGroup != nil}
      /// Clears the value of `mainGroup`. Subsequent reads from it will return its default value.
      public mutating func clearMainGroup() {_uniqueStorage()._mainGroup = nil}

      public var sshPwAuth: Bool {
        get {_storage._sshPwAuth ?? false}
        set {_uniqueStorage()._sshPwAuth = newValue}
      }
      /// Returns true if `sshPwAuth` has been explicitly set.
      public var hasSshPwAuth: Bool {_storage._sshPwAuth != nil}
      /// Clears the value of `sshPwAuth`. Subsequent reads from it will return its default value.
      public mutating func clearSshPwAuth() {_uniqueStorage()._sshPwAuth = nil}

      public var image: String {
        get {_storage._image ?? String()}
        set {_uniqueStorage()._image = newValue}
      }
      /// Returns true if `image` has been explicitly set.
      public var hasImage: Bool {_storage._image != nil}
      /// Clears the value of `image`. Subsequent reads from it will return its default value.
      public mutating func clearImage() {_uniqueStorage()._image = nil}

      public var sshAuthorizedKey: Data {
        get {_storage._sshAuthorizedKey ?? Data()}
        set {_uniqueStorage()._sshAuthorizedKey = newValue}
      }
      /// Returns true if `sshAuthorizedKey` has been explicitly set.
      public var hasSshAuthorizedKey: Bool {_storage._sshAuthorizedKey != nil}
      /// Clears the value of `sshAuthorizedKey`. Subsequent reads from it will return its default value.
      public mutating func clearSshAuthorizedKey() {_uniqueStorage()._sshAuthorizedKey = nil}

      public var vendorData: Data {
        get {_storage._vendorData ?? Data()}
        set {_uniqueStorage()._vendorData = newValue}
      }
      /// Returns true if `vendorData` has been explicitly set.
      public var hasVendorData: Bool {_storage._vendorData != nil}
      /// Clears the value of `vendorData`. Subsequent reads from it will return its default value.
      public mutating func clearVendorData() {_uniqueStorage()._vendorData = nil}

      public var userData: Data {
        get {_storage._userData ?? Data()}
        set {_uniqueStorage()._userData = newValue}
      }
      /// Returns true if `userData` has been explicitly set.
      public var hasUserData: Bool {_storage._userData != nil}
      /// Clears the value of `userData`. Subsequent reads from it will return its default value.
      public mutating func clearUserData() {_uniqueStorage()._userData = nil}

      public var networkConfig: Data {
        get {_storage._networkConfig ?? Data()}
        set {_uniqueStorage()._networkConfig = newValue}
      }
      /// Returns true if `networkConfig` has been explicitly set.
      public var hasNetworkConfig: Bool {_storage._networkConfig != nil}
      /// Clears the value of `networkConfig`. Subsequent reads from it will return its default value.
      public mutating func clearNetworkConfig() {_uniqueStorage()._networkConfig = nil}

      public var diskSize: Int32 {
        get {_storage._diskSize ?? 0}
        set {_uniqueStorage()._diskSize = newValue}
      }
      /// Returns true if `diskSize` has been explicitly set.
      public var hasDiskSize: Bool {_storage._diskSize != nil}
      /// Clears the value of `diskSize`. Subsequent reads from it will return its default value.
      public mutating func clearDiskSize() {_uniqueStorage()._diskSize = nil}

      public var autostart: Bool {
        get {_storage._autostart ?? false}
        set {_uniqueStorage()._autostart = newValue}
      }
      /// Returns true if `autostart` has been explicitly set.
      public var hasAutostart: Bool {_storage._autostart != nil}
      /// Clears the value of `autostart`. Subsequent reads from it will return its default value.
      public mutating func clearAutostart() {_uniqueStorage()._autostart = nil}

      public var nested: Bool {
        get {_storage._nested ?? false}
        set {_uniqueStorage()._nested = newValue}
      }
      /// Returns true if `nested` has been explicitly set.
      public var hasNested: Bool {_storage._nested != nil}
      /// Clears the value of `nested`. Subsequent reads from it will return its default value.
      public mutating func clearNested() {_uniqueStorage()._nested = nil}

      public var forwardedPort: String {
        get {_storage._forwardedPort ?? String()}
        set {_uniqueStorage()._forwardedPort = newValue}
      }
      /// Returns true if `forwardedPort` has been explicitly set.
      public var hasForwardedPort: Bool {_storage._forwardedPort != nil}
      /// Clears the value of `forwardedPort`. Subsequent reads from it will return its default value.
      public mutating func clearForwardedPort() {_uniqueStorage()._forwardedPort = nil}

      public var mounts: String {
        get {_storage._mounts ?? String()}
        set {_uniqueStorage()._mounts = newValue}
      }
      /// Returns true if `mounts` has been explicitly set.
      public var hasMounts: Bool {_storage._mounts != nil}
      /// Clears the value of `mounts`. Subsequent reads from it will return its default value.
      public mutating func clearMounts() {_uniqueStorage()._mounts = nil}

      public var networks: String {
        get {_storage._networks ?? String()}
        set {_uniqueStorage()._networks = newValue}
      }
      /// Returns true if `networks` has been explicitly set.
      public var hasNetworks: Bool {_storage._networks != nil}
      /// Clears the value of `networks`. Subsequent reads from it will return its default value.
      public mutating func clearNetworks() {_uniqueStorage()._networks = nil}

      public var sockets: String {
        get {_storage._sockets ?? String()}
        set {_uniqueStorage()._sockets = newValue}
      }
      /// Returns true if `sockets` has been explicitly set.
      public var hasSockets: Bool {_storage._sockets != nil}
      /// Clears the value of `sockets`. Subsequent reads from it will return its default value.
      public mutating func clearSockets() {_uniqueStorage()._sockets = nil}

      public var console: String {
        get {_storage._console ?? String()}
        set {_uniqueStorage()._console = newValue}
      }
      /// Returns true if `console` has been explicitly set.
      public var hasConsole: Bool {_storage._console != nil}
      /// Clears the value of `console`. Subsequent reads from it will return its default value.
      public mutating func clearConsole() {_uniqueStorage()._console = nil}

      public var attachedDisks: String {
        get {_storage._attachedDisks ?? String()}
        set {_uniqueStorage()._attachedDisks = newValue}
      }
      /// Returns true if `attachedDisks` has been explicitly set.
      public var hasAttachedDisks: Bool {_storage._attachedDisks != nil}
      /// Clears the value of `attachedDisks`. Subsequent reads from it will return its default value.
      public mutating func clearAttachedDisks() {_uniqueStorage()._attachedDisks = nil}

      public var dynamicPortForwarding: Bool {
        get {_storage._dynamicPortForwarding ?? false}
        set {_uniqueStorage()._dynamicPortForwarding = newValue}
      }
      /// Returns true if `dynamicPortForwarding` has been explicitly set.
      public var hasDynamicPortForwarding: Bool {_storage._dynamicPortForwarding != nil}
      /// Clears the value of `dynamicPortForwarding`. Subsequent reads from it will return its default value.
      public mutating func clearDynamicPortForwarding() {_uniqueStorage()._dynamicPortForwarding = nil}

      public var ifnames: Bool {
        get {_storage._ifnames ?? false}
        set {_uniqueStorage()._ifnames = newValue}
      }
      /// Returns true if `ifnames` has been explicitly set.
      public var hasIfnames: Bool {_storage._ifnames != nil}
      /// Clears the value of `ifnames`. Subsequent reads from it will return its default value.
      public mutating func clearIfnames() {_uniqueStorage()._ifnames = nil}

      public var suspendable: Bool {
        get {_storage._suspendable ?? false}
        set {_uniqueStorage()._suspendable = newValue}
      }
      /// Returns true if `suspendable` has been explicitly set.
      public var hasSuspendable: Bool {_storage._suspendable != nil}
      /// Clears the value of `suspendable`. Subsequent reads from it will return its default value.
      public mutating func clearSuspendable() {_uniqueStorage()._suspendable = nil}

      public var screenSize: Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize {
        get {_storage._screenSize ?? Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize()}
        set {_uniqueStorage()._screenSize = newValue}
      }
      /// Returns true if `screenSize` has been explicitly set.
      public var hasScreenSize: Bool {_storage._screenSize != nil}
      /// Clears the value of `screenSize`. Subsequent reads from it will return its default value.
      public mutating func clearScreenSize() {_uniqueStorage()._screenSize = nil}

      public var displayRefit: Bool {
        get {_storage._displayRefit ?? false}
        set {_uniqueStorage()._displayRefit = newValue}
      }
      /// Returns true if `displayRefit` has been explicitly set.
      public var hasDisplayRefit: Bool {_storage._displayRefit != nil}
      /// Clears the value of `displayRefit`. Subsequent reads from it will return its default value.
      public mutating func clearDisplayRefit() {_uniqueStorage()._displayRefit = nil}

      public var otherGroups: String {
        get {_storage._otherGroups ?? String()}
        set {_uniqueStorage()._otherGroups = newValue}
      }
      /// Returns true if `otherGroups` has been explicitly set.
      public var hasOtherGroups: Bool {_storage._otherGroups != nil}
      /// Clears the value of `otherGroups`. Subsequent reads from it will return its default value.
      public mutating func clearOtherGroups() {_uniqueStorage()._otherGroups = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct ScreenSize: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var width: Int32 = 0

        public var height: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public struct BuildRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var options: Caked_Caked.VMRequest.CommonBuildRequest {
        get {_options ?? Caked_Caked.VMRequest.CommonBuildRequest()}
        set {_options = newValue}
      }
      /// Returns true if `options` has been explicitly set.
      public var hasOptions: Bool {self._options != nil}
      /// Clears the value of `options`. Subsequent reads from it will return its default value.
      public mutating func clearOptions() {self._options = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _options: Caked_Caked.VMRequest.CommonBuildRequest? = nil
    }

    public struct StartRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var waitIptimeout: Int32 {
        get {_waitIptimeout ?? 0}
        set {_waitIptimeout = newValue}
      }
      /// Returns true if `waitIptimeout` has been explicitly set.
      public var hasWaitIptimeout: Bool {self._waitIptimeout != nil}
      /// Clears the value of `waitIptimeout`. Subsequent reads from it will return its default value.
      public mutating func clearWaitIptimeout() {self._waitIptimeout = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _waitIptimeout: Int32? = nil
    }

    public struct CloneRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var sourceName: String = String()

      public var targetName: String = String()

      public var insecure: Bool {
        get {_insecure ?? false}
        set {_insecure = newValue}
      }
      /// Returns true if `insecure` has been explicitly set.
      public var hasInsecure: Bool {self._insecure != nil}
      /// Clears the value of `insecure`. Subsequent reads from it will return its default value.
      public mutating func clearInsecure() {self._insecure = nil}

      public var concurrency: UInt32 {
        get {_concurrency ?? 0}
        set {_concurrency = newValue}
      }
      /// Returns true if `concurrency` has been explicitly set.
      public var hasConcurrency: Bool {self._concurrency != nil}
      /// Clears the value of `concurrency`. Subsequent reads from it will return its default value.
      public mutating func clearConcurrency() {self._concurrency = nil}

      public var deduplicate: Bool {
        get {_deduplicate ?? false}
        set {_deduplicate = newValue}
      }
      /// Returns true if `deduplicate` has been explicitly set.
      public var hasDeduplicate: Bool {self._deduplicate != nil}
      /// Clears the value of `deduplicate`. Subsequent reads from it will return its default value.
      public mutating func clearDeduplicate() {self._deduplicate = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _insecure: Bool? = nil
      fileprivate var _concurrency: UInt32? = nil
      fileprivate var _deduplicate: Bool? = nil
    }

    public struct DuplicateRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var from: String = String()

      public var to: String = String()

      public var resetMacAddress: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct LaunchRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var options: Caked_Caked.VMRequest.CommonBuildRequest {
        get {_options ?? Caked_Caked.VMRequest.CommonBuildRequest()}
        set {_options = newValue}
      }
      /// Returns true if `options` has been explicitly set.
      public var hasOptions: Bool {self._options != nil}
      /// Clears the value of `options`. Subsequent reads from it will return its default value.
      public mutating func clearOptions() {self._options = nil}

      public var waitIptimeout: Int32 {
        get {_waitIptimeout ?? 0}
        set {_waitIptimeout = newValue}
      }
      /// Returns true if `waitIptimeout` has been explicitly set.
      public var hasWaitIptimeout: Bool {self._waitIptimeout != nil}
      /// Clears the value of `waitIptimeout`. Subsequent reads from it will return its default value.
      public mutating func clearWaitIptimeout() {self._waitIptimeout = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _options: Caked_Caked.VMRequest.CommonBuildRequest? = nil
      fileprivate var _waitIptimeout: Int32? = nil
    }

    public struct ConfigureRequest: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String {
        get {_storage._name}
        set {_uniqueStorage()._name = newValue}
      }

      public var cpu: Int32 {
        get {_storage._cpu ?? 0}
        set {_uniqueStorage()._cpu = newValue}
      }
      /// Returns true if `cpu` has been explicitly set.
      public var hasCpu: Bool {_storage._cpu != nil}
      /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
      public mutating func clearCpu() {_uniqueStorage()._cpu = nil}

      public var memory: Int32 {
        get {_storage._memory ?? 0}
        set {_uniqueStorage()._memory = newValue}
      }
      /// Returns true if `memory` has been explicitly set.
      public var hasMemory: Bool {_storage._memory != nil}
      /// Clears the value of `memory`. Subsequent reads from it will return its default value.
      public mutating func clearMemory() {_uniqueStorage()._memory = nil}

      public var diskSize: Int32 {
        get {_storage._diskSize ?? 0}
        set {_uniqueStorage()._diskSize = newValue}
      }
      /// Returns true if `diskSize` has been explicitly set.
      public var hasDiskSize: Bool {_storage._diskSize != nil}
      /// Clears the value of `diskSize`. Subsequent reads from it will return its default value.
      public mutating func clearDiskSize() {_uniqueStorage()._diskSize = nil}

      public var displayRefit: Bool {
        get {_storage._displayRefit ?? false}
        set {_uniqueStorage()._displayRefit = newValue}
      }
      /// Returns true if `displayRefit` has been explicitly set.
      public var hasDisplayRefit: Bool {_storage._displayRefit != nil}
      /// Clears the value of `displayRefit`. Subsequent reads from it will return its default value.
      public mutating func clearDisplayRefit() {_uniqueStorage()._displayRefit = nil}

      public var autostart: Bool {
        get {_storage._autostart ?? false}
        set {_uniqueStorage()._autostart = newValue}
      }
      /// Returns true if `autostart` has been explicitly set.
      public var hasAutostart: Bool {_storage._autostart != nil}
      /// Clears the value of `autostart`. Subsequent reads from it will return its default value.
      public mutating func clearAutostart() {_uniqueStorage()._autostart = nil}

      public var nested: Bool {
        get {_storage._nested ?? false}
        set {_uniqueStorage()._nested = newValue}
      }
      /// Returns true if `nested` has been explicitly set.
      public var hasNested: Bool {_storage._nested != nil}
      /// Clears the value of `nested`. Subsequent reads from it will return its default value.
      public mutating func clearNested() {_uniqueStorage()._nested = nil}

      public var mounts: String {
        get {_storage._mounts ?? String()}
        set {_uniqueStorage()._mounts = newValue}
      }
      /// Returns true if `mounts` has been explicitly set.
      public var hasMounts: Bool {_storage._mounts != nil}
      /// Clears the value of `mounts`. Subsequent reads from it will return its default value.
      public mutating func clearMounts() {_uniqueStorage()._mounts = nil}

      public var networks: String {
        get {_storage._networks ?? String()}
        set {_uniqueStorage()._networks = newValue}
      }
      /// Returns true if `networks` has been explicitly set.
      public var hasNetworks: Bool {_storage._networks != nil}
      /// Clears the value of `networks`. Subsequent reads from it will return its default value.
      public mutating func clearNetworks() {_uniqueStorage()._networks = nil}

      public var sockets: String {
        get {_storage._sockets ?? String()}
        set {_uniqueStorage()._sockets = newValue}
      }
      /// Returns true if `sockets` has been explicitly set.
      public var hasSockets: Bool {_storage._sockets != nil}
      /// Clears the value of `sockets`. Subsequent reads from it will return its default value.
      public mutating func clearSockets() {_uniqueStorage()._sockets = nil}

      public var console: String {
        get {_storage._console ?? String()}
        set {_uniqueStorage()._console = newValue}
      }
      /// Returns true if `console` has been explicitly set.
      public var hasConsole: Bool {_storage._console != nil}
      /// Clears the value of `console`. Subsequent reads from it will return its default value.
      public mutating func clearConsole() {_uniqueStorage()._console = nil}

      public var randomMac: Bool {
        get {_storage._randomMac ?? false}
        set {_uniqueStorage()._randomMac = newValue}
      }
      /// Returns true if `randomMac` has been explicitly set.
      public var hasRandomMac: Bool {_storage._randomMac != nil}
      /// Clears the value of `randomMac`. Subsequent reads from it will return its default value.
      public mutating func clearRandomMac() {_uniqueStorage()._randomMac = nil}

      public var forwardedPort: String {
        get {_storage._forwardedPort ?? String()}
        set {_uniqueStorage()._forwardedPort = newValue}
      }
      /// Returns true if `forwardedPort` has been explicitly set.
      public var hasForwardedPort: Bool {_storage._forwardedPort != nil}
      /// Clears the value of `forwardedPort`. Subsequent reads from it will return its default value.
      public mutating func clearForwardedPort() {_uniqueStorage()._forwardedPort = nil}

      public var attachedDisks: String {
        get {_storage._attachedDisks ?? String()}
        set {_uniqueStorage()._attachedDisks = newValue}
      }
      /// Returns true if `attachedDisks` has been explicitly set.
      public var hasAttachedDisks: Bool {_storage._attachedDisks != nil}
      /// Clears the value of `attachedDisks`. Subsequent reads from it will return its default value.
      public mutating func clearAttachedDisks() {_uniqueStorage()._attachedDisks = nil}

      public var dynamicPortForwarding: Bool {
        get {_storage._dynamicPortForwarding ?? false}
        set {_uniqueStorage()._dynamicPortForwarding = newValue}
      }
      /// Returns true if `dynamicPortForwarding` has been explicitly set.
      public var hasDynamicPortForwarding: Bool {_storage._dynamicPortForwarding != nil}
      /// Clears the value of `dynamicPortForwarding`. Subsequent reads from it will return its default value.
      public mutating func clearDynamicPortForwarding() {_uniqueStorage()._dynamicPortForwarding = nil}

      public var suspendable: Bool {
        get {_storage._suspendable ?? false}
        set {_uniqueStorage()._suspendable = newValue}
      }
      /// Returns true if `suspendable` has been explicitly set.
      public var hasSuspendable: Bool {_storage._suspendable != nil}
      /// Clears the value of `suspendable`. Subsequent reads from it will return its default value.
      public mutating func clearSuspendable() {_uniqueStorage()._suspendable = nil}

      public var screenSize: Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize {
        get {_storage._screenSize ?? Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize()}
        set {_uniqueStorage()._screenSize = newValue}
      }
      /// Returns true if `screenSize` has been explicitly set.
      public var hasScreenSize: Bool {_storage._screenSize != nil}
      /// Clears the value of `screenSize`. Subsequent reads from it will return its default value.
      public mutating func clearScreenSize() {_uniqueStorage()._screenSize = nil}

      public var user: String {
        get {_storage._user ?? String()}
        set {_uniqueStorage()._user = newValue}
      }
      /// Returns true if `user` has been explicitly set.
      public var hasUser: Bool {_storage._user != nil}
      /// Clears the value of `user`. Subsequent reads from it will return its default value.
      public mutating func clearUser() {_uniqueStorage()._user = nil}

      public var password: String {
        get {_storage._password ?? String()}
        set {_uniqueStorage()._password = newValue}
      }
      /// Returns true if `password` has been explicitly set.
      public var hasPassword: Bool {_storage._password != nil}
      /// Clears the value of `password`. Subsequent reads from it will return its default value.
      public mutating func clearPassword() {_uniqueStorage()._password = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public struct WaitIPRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var timeout: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct StopRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var force: Bool = false

      public var stop: Caked_Caked.VMRequest.StopRequest.OneOf_Stop? = nil

      public var all: Bool {
        get {
          if case .all(let v)? = stop {return v}
          return false
        }
        set {stop = .all(newValue)}
      }

      public var names: Caked_Caked.VMRequest.StopRequest.VMNames {
        get {
          if case .names(let v)? = stop {return v}
          return Caked_Caked.VMRequest.StopRequest.VMNames()
        }
        set {stop = .names(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Stop: Equatable, Sendable {
        case all(Bool)
        case names(Caked_Caked.VMRequest.StopRequest.VMNames)

      }

      public struct VMNames: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var list: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public struct SuspendRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var names: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct DeleteRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var delete: Caked_Caked.VMRequest.DeleteRequest.OneOf_Delete? = nil

      public var all: Bool {
        get {
          if case .all(let v)? = delete {return v}
          return false
        }
        set {delete = .all(newValue)}
      }

      public var names: Caked_Caked.VMRequest.DeleteRequest.VMNames {
        get {
          if case .names(let v)? = delete {return v}
          return Caked_Caked.VMRequest.DeleteRequest.VMNames()
        }
        set {delete = .names(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Delete: Equatable, Sendable {
        case all(Bool)
        case names(Caked_Caked.VMRequest.DeleteRequest.VMNames)

      }

      public struct VMNames: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var list: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public struct ListRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var vmonly: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct InfoRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct RenameRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var oldname: String = String()

      public var newname: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct TemplateRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var command: Caked_Caked.VMRequest.TemplateRequest.TemplateCommand = .none

      public var template: Caked_Caked.VMRequest.TemplateRequest.OneOf_Template? = nil

      public var createRequest: Caked_Caked.VMRequest.TemplateRequest.TemplateRequestAdd {
        get {
          if case .createRequest(let v)? = template {return v}
          return Caked_Caked.VMRequest.TemplateRequest.TemplateRequestAdd()
        }
        set {template = .createRequest(newValue)}
      }

      public var deleteRequest: String {
        get {
          if case .deleteRequest(let v)? = template {return v}
          return String()
        }
        set {template = .deleteRequest(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Template: Equatable, Sendable {
        case createRequest(Caked_Caked.VMRequest.TemplateRequest.TemplateRequestAdd)
        case deleteRequest(String)

      }

      public enum TemplateCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int
        case none // = 0
        case add // = 1
        case delete // = 2
        case list // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .none
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .add
          case 2: self = .delete
          case 3: self = .list
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .none: return 0
          case .add: return 1
          case .delete: return 2
          case .list: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Caked_Caked.VMRequest.TemplateRequest.TemplateCommand] = [
          .none,
          .add,
          .delete,
          .list,
        ]

      }

      public struct TemplateRequestAdd: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var sourceName: String = String()

        public var templateName: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public struct RunCommand: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var vmname: String = String()

      public var command: String = String()

      public var args: [String] = []

      public var input: Data {
        get {_input ?? Data()}
        set {_input = newValue}
      }
      /// Returns true if `input` has been explicitly set.
      public var hasInput: Bool {self._input != nil}
      /// Clears the value of `input`. Subsequent reads from it will return its default value.
      public mutating func clearInput() {self._input = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _input: Data? = nil
    }

    public struct ExecuteResponse: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Caked_Caked.VMRequest.ExecuteResponse.OneOf_Response? = nil

      public var exitCode: Int32 {
        get {
          if case .exitCode(let v)? = response {return v}
          return 0
        }
        set {response = .exitCode(newValue)}
      }

      public var stdout: Data {
        get {
          if case .stdout(let v)? = response {return v}
          return Data()
        }
        set {response = .stdout(newValue)}
      }

      public var stderr: Data {
        get {
          if case .stderr(let v)? = response {return v}
          return Data()
        }
        set {response = .stderr(newValue)}
      }

      public var failure: String {
        get {
          if case .failure(let v)? = response {return v}
          return String()
        }
        set {response = .failure(newValue)}
      }

      public var established: Bool {
        get {
          if case .established(let v)? = response {return v}
          return false
        }
        set {response = .established(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case exitCode(Int32)
        case stdout(Data)
        case stderr(Data)
        case failure(String)
        case established(Bool)

      }

      public init() {}
    }

    public struct ExecuteRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var execute: Caked_Caked.VMRequest.ExecuteRequest.OneOf_Execute? = nil

      public var command: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand {
        get {
          if case .command(let v)? = execute {return v}
          return Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand()
        }
        set {execute = .command(newValue)}
      }

      public var input: Data {
        get {
          if case .input(let v)? = execute {return v}
          return Data()
        }
        set {execute = .input(newValue)}
      }

      public var size: Caked_Caked.VMRequest.ExecuteRequest.TerminalSize {
        get {
          if case .size(let v)? = execute {return v}
          return Caked_Caked.VMRequest.ExecuteRequest.TerminalSize()
        }
        set {execute = .size(newValue)}
      }

      public var eof: Bool {
        get {
          if case .eof(let v)? = execute {return v}
          return false
        }
        set {execute = .eof(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Execute: Equatable, Sendable {
        case command(Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand)
        case input(Data)
        case size(Caked_Caked.VMRequest.ExecuteRequest.TerminalSize)
        case eof(Bool)

      }

      public struct ExecuteCommand: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var execute: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.OneOf_Execute? = nil

        public var command: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.Command {
          get {
            if case .command(let v)? = execute {return v}
            return Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.Command()
          }
          set {execute = .command(newValue)}
        }

        public var shell: Bool {
          get {
            if case .shell(let v)? = execute {return v}
            return false
          }
          set {execute = .shell(newValue)}
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Execute: Equatable, Sendable {
          case command(Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.Command)
          case shell(Bool)

        }

        public struct Command: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var command: String = String()

          public var args: [String] = []

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}
      }

      public struct TerminalSize: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var rows: Int32 = 0

        public var cols: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public struct Reply: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var response: Caked_Caked.Reply.OneOf_Response? = nil

    public var vms: Caked_Caked.Reply.VirtualMachineReply {
      get {
        if case .vms(let v)? = response {return v}
        return Caked_Caked.Reply.VirtualMachineReply()
      }
      set {response = .vms(newValue)}
    }

    public var images: Caked_Caked.Reply.ImageReply {
      get {
        if case .images(let v)? = response {return v}
        return Caked_Caked.Reply.ImageReply()
      }
      set {response = .images(newValue)}
    }

    public var networks: Caked_Caked.Reply.NetworksReply {
      get {
        if case .networks(let v)? = response {return v}
        return Caked_Caked.Reply.NetworksReply()
      }
      set {response = .networks(newValue)}
    }

    public var remotes: Caked_Caked.Reply.RemoteReply {
      get {
        if case .remotes(let v)? = response {return v}
        return Caked_Caked.Reply.RemoteReply()
      }
      set {response = .remotes(newValue)}
    }

    public var templates: Caked_Caked.Reply.TemplateReply {
      get {
        if case .templates(let v)? = response {return v}
        return Caked_Caked.Reply.TemplateReply()
      }
      set {response = .templates(newValue)}
    }

    public var run: Caked_Caked.Reply.RunReply {
      get {
        if case .run(let v)? = response {return v}
        return Caked_Caked.Reply.RunReply()
      }
      set {response = .run(newValue)}
    }

    public var mounts: Caked_Caked.Reply.MountReply {
      get {
        if case .mounts(let v)? = response {return v}
        return Caked_Caked.Reply.MountReply()
      }
      set {response = .mounts(newValue)}
    }

    public var oci: Caked_Caked.Reply.OCIReply {
      get {
        if case .oci(let v)? = response {return v}
        return Caked_Caked.Reply.OCIReply()
      }
      set {response = .oci(newValue)}
    }

    public var ping: Caked_Caked.Reply.PingReply {
      get {
        if case .ping(let v)? = response {return v}
        return Caked_Caked.Reply.PingReply()
      }
      set {response = .ping(newValue)}
    }

    public var status: Caked_Caked.Reply.CurrentStatusReply {
      get {
        if case .status(let v)? = response {return v}
        return Caked_Caked.Reply.CurrentStatusReply()
      }
      set {response = .status(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Response: Equatable, Sendable {
      case vms(Caked_Caked.Reply.VirtualMachineReply)
      case images(Caked_Caked.Reply.ImageReply)
      case networks(Caked_Caked.Reply.NetworksReply)
      case remotes(Caked_Caked.Reply.RemoteReply)
      case templates(Caked_Caked.Reply.TemplateReply)
      case run(Caked_Caked.Reply.RunReply)
      case mounts(Caked_Caked.Reply.MountReply)
      case oci(Caked_Caked.Reply.OCIReply)
      case ping(Caked_Caked.Reply.PingReply)
      case status(Caked_Caked.Reply.CurrentStatusReply)

    }

    public struct CurrentUsageReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var cpuCount: Int32 = 0

      public var cpuInfos: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo {
        get {_cpuInfos ?? Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo()}
        set {_cpuInfos = newValue}
      }
      /// Returns true if `cpuInfos` has been explicitly set.
      public var hasCpuInfos: Bool {self._cpuInfos != nil}
      /// Clears the value of `cpuInfos`. Subsequent reads from it will return its default value.
      public mutating func clearCpuInfos() {self._cpuInfos = nil}

      public var memory: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo {
        get {_memory ?? Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo()}
        set {_memory = newValue}
      }
      /// Returns true if `memory` has been explicitly set.
      public var hasMemory: Bool {self._memory != nil}
      /// Clears the value of `memory`. Subsequent reads from it will return its default value.
      public mutating func clearMemory() {self._memory = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _cpuInfos: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo? = nil
      fileprivate var _memory: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo? = nil
    }

    public struct CurrentStatusReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Caked_Caked.Reply.CurrentStatusReply.OneOf_Response? = nil

      public var usage: Caked_Caked.Reply.CurrentUsageReply {
        get {
          if case .usage(let v)? = response {return v}
          return Caked_Caked.Reply.CurrentUsageReply()
        }
        set {response = .usage(newValue)}
      }

      public var screenshot: Data {
        get {
          if case .screenshot(let v)? = response {return v}
          return Data()
        }
        set {response = .screenshot(newValue)}
      }

      public var currentStatus: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.VirtualMachineStatus {
        get {
          if case .currentStatus(let v)? = response {return v}
          return .stopped
        }
        set {response = .currentStatus(newValue)}
      }

      public var failure: String {
        get {
          if case .failure(let v)? = response {return v}
          return String()
        }
        set {response = .failure(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case usage(Caked_Caked.Reply.CurrentUsageReply)
        case screenshot(Data)
        case currentStatus(Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.VirtualMachineStatus)
        case failure(String)

      }

      public init() {}
    }

    public struct PingReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var success: Bool = false

      public var message: String = String()

      public var currentStatus: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.VirtualMachineStatus = .stopped

      public var requestTimestamp: Int64 = 0

      public var responseTimestamp: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct VirtualMachineReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Caked_Caked.Reply.VirtualMachineReply.OneOf_Response? = nil

      public var list: Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply {
        get {
          if case .list(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply()
        }
        set {response = .list(newValue)}
      }

      public var delete: Caked_Caked.Reply.VirtualMachineReply.DeleteReply {
        get {
          if case .delete(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.DeleteReply()
        }
        set {response = .delete(newValue)}
      }

      public var stop: Caked_Caked.Reply.VirtualMachineReply.StopReply {
        get {
          if case .stop(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.StopReply()
        }
        set {response = .stop(newValue)}
      }

      public var suspend: Caked_Caked.Reply.VirtualMachineReply.SuspendReply {
        get {
          if case .suspend(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.SuspendReply()
        }
        set {response = .suspend(newValue)}
      }

      public var status: Caked_Caked.Reply.VirtualMachineReply.StatusReply {
        get {
          if case .status(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.StatusReply()
        }
        set {response = .status(newValue)}
      }

      public var launched: Caked_Caked.Reply.VirtualMachineReply.LaunchReply {
        get {
          if case .launched(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.LaunchReply()
        }
        set {response = .launched(newValue)}
      }

      public var started: Caked_Caked.Reply.VirtualMachineReply.StartedReply {
        get {
          if case .started(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.StartedReply()
        }
        set {response = .started(newValue)}
      }

      public var build: Caked_Caked.Reply.VirtualMachineReply.BuildStreamReply {
        get {
          if case .build(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.BuildStreamReply()
        }
        set {response = .build(newValue)}
      }

      public var cloned: Caked_Caked.Reply.VirtualMachineReply.ClonedReply {
        get {
          if case .cloned(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.ClonedReply()
        }
        set {response = .cloned(newValue)}
      }

      public var configured: Caked_Caked.Reply.VirtualMachineReply.ConfiguredReply {
        get {
          if case .configured(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.ConfiguredReply()
        }
        set {response = .configured(newValue)}
      }

      public var duplicated: Caked_Caked.Reply.VirtualMachineReply.DuplicatedReply {
        get {
          if case .duplicated(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.DuplicatedReply()
        }
        set {response = .duplicated(newValue)}
      }

      public var imported: Caked_Caked.Reply.VirtualMachineReply.ImportedReply {
        get {
          if case .imported(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.ImportedReply()
        }
        set {response = .imported(newValue)}
      }

      public var waitip: Caked_Caked.Reply.VirtualMachineReply.WaitIPReply {
        get {
          if case .waitip(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.WaitIPReply()
        }
        set {response = .waitip(newValue)}
      }

      public var purged: Caked_Caked.Reply.VirtualMachineReply.PurgeReply {
        get {
          if case .purged(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.PurgeReply()
        }
        set {response = .purged(newValue)}
      }

      public var renamed: Caked_Caked.Reply.VirtualMachineReply.RenameReply {
        get {
          if case .renamed(let v)? = response {return v}
          return Caked_Caked.Reply.VirtualMachineReply.RenameReply()
        }
        set {response = .renamed(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case list(Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply)
        case delete(Caked_Caked.Reply.VirtualMachineReply.DeleteReply)
        case stop(Caked_Caked.Reply.VirtualMachineReply.StopReply)
        case suspend(Caked_Caked.Reply.VirtualMachineReply.SuspendReply)
        case status(Caked_Caked.Reply.VirtualMachineReply.StatusReply)
        case launched(Caked_Caked.Reply.VirtualMachineReply.LaunchReply)
        case started(Caked_Caked.Reply.VirtualMachineReply.StartedReply)
        case build(Caked_Caked.Reply.VirtualMachineReply.BuildStreamReply)
        case cloned(Caked_Caked.Reply.VirtualMachineReply.ClonedReply)
        case configured(Caked_Caked.Reply.VirtualMachineReply.ConfiguredReply)
        case duplicated(Caked_Caked.Reply.VirtualMachineReply.DuplicatedReply)
        case imported(Caked_Caked.Reply.VirtualMachineReply.ImportedReply)
        case waitip(Caked_Caked.Reply.VirtualMachineReply.WaitIPReply)
        case purged(Caked_Caked.Reply.VirtualMachineReply.PurgeReply)
        case renamed(Caked_Caked.Reply.VirtualMachineReply.RenameReply)

      }

      public struct VirtualMachineInfoReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var infos: [Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply.VirtualMachineInfo] = []

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var success: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct VirtualMachineInfo: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var type: String = String()

          public var source: String = String()

          public var name: String = String()

          public var fqn: [String] = []

          public var instanceID: String {
            get {_instanceID ?? String()}
            set {_instanceID = newValue}
          }
          /// Returns true if `instanceID` has been explicitly set.
          public var hasInstanceID: Bool {self._instanceID != nil}
          /// Clears the value of `instanceID`. Subsequent reads from it will return its default value.
          public mutating func clearInstanceID() {self._instanceID = nil}

          public var diskSize: UInt64 = 0

          public var sizeOnDisk: UInt64 = 0

          public var state: String = String()

          public var ip: String {
            get {_ip ?? String()}
            set {_ip = newValue}
          }
          /// Returns true if `ip` has been explicitly set.
          public var hasIp: Bool {self._ip != nil}
          /// Clears the value of `ip`. Subsequent reads from it will return its default value.
          public mutating func clearIp() {self._ip = nil}

          public var fingerprint: String {
            get {_fingerprint ?? String()}
            set {_fingerprint = newValue}
          }
          /// Returns true if `fingerprint` has been explicitly set.
          public var hasFingerprint: Bool {self._fingerprint != nil}
          /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
          public mutating func clearFingerprint() {self._fingerprint = nil}

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _instanceID: String? = nil
          fileprivate var _ip: String? = nil
          fileprivate var _fingerprint: String? = nil
        }

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct DeleteReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var objects: [Caked_Caked.Reply.VirtualMachineReply.DeleteReply.DeletedObject] = []

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var success: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct DeletedObject: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var source: String = String()

          public var name: String = String()

          public var deleted: Bool = false

          public var reason: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct StopReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var success: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var objects: [Caked_Caked.Reply.VirtualMachineReply.StopReply.StoppedObject] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct StoppedObject: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var name: String = String()

          public var stopped: Bool = false

          public var reason: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct SuspendReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var objects: [Caked_Caked.Reply.VirtualMachineReply.SuspendReply.SuspendedObject] = []

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var success: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct SuspendedObject: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var name: String = String()

          public var suspended: Bool = false

          public var reason: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct StatusReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var status: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply {
          get {_status ?? Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply()}
          set {_status = newValue}
        }
        /// Returns true if `status` has been explicitly set.
        public var hasStatus: Bool {self._status != nil}
        /// Clears the value of `status`. Subsequent reads from it will return its default value.
        public mutating func clearStatus() {self._status = nil}

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var success: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct InfoReply: @unchecked Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var version: String {
            get {_storage._version ?? String()}
            set {_uniqueStorage()._version = newValue}
          }
          /// Returns true if `version` has been explicitly set.
          public var hasVersion: Bool {_storage._version != nil}
          /// Clears the value of `version`. Subsequent reads from it will return its default value.
          public mutating func clearVersion() {_uniqueStorage()._version = nil}

          public var uptime: UInt64 {
            get {_storage._uptime ?? 0}
            set {_uniqueStorage()._uptime = newValue}
          }
          /// Returns true if `uptime` has been explicitly set.
          public var hasUptime: Bool {_storage._uptime != nil}
          /// Clears the value of `uptime`. Subsequent reads from it will return its default value.
          public mutating func clearUptime() {_uniqueStorage()._uptime = nil}

          public var memory: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo {
            get {_storage._memory ?? Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo()}
            set {_uniqueStorage()._memory = newValue}
          }
          /// Returns true if `memory` has been explicitly set.
          public var hasMemory: Bool {_storage._memory != nil}
          /// Clears the value of `memory`. Subsequent reads from it will return its default value.
          public mutating func clearMemory() {_uniqueStorage()._memory = nil}

          public var cpuCount: Int32 {
            get {_storage._cpuCount}
            set {_uniqueStorage()._cpuCount = newValue}
          }

          public var diskInfos: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.DiskInfo] {
            get {_storage._diskInfos}
            set {_uniqueStorage()._diskInfos = newValue}
          }

          public var ipaddresses: [String] {
            get {_storage._ipaddresses}
            set {_uniqueStorage()._ipaddresses = newValue}
          }

          public var osname: String {
            get {_storage._osname}
            set {_uniqueStorage()._osname = newValue}
          }

          public var hostname: String {
            get {_storage._hostname ?? String()}
            set {_uniqueStorage()._hostname = newValue}
          }
          /// Returns true if `hostname` has been explicitly set.
          public var hasHostname: Bool {_storage._hostname != nil}
          /// Clears the value of `hostname`. Subsequent reads from it will return its default value.
          public mutating func clearHostname() {_uniqueStorage()._hostname = nil}

          public var release: String {
            get {_storage._release ?? String()}
            set {_uniqueStorage()._release = newValue}
          }
          /// Returns true if `release` has been explicitly set.
          public var hasRelease: Bool {_storage._release != nil}
          /// Clears the value of `release`. Subsequent reads from it will return its default value.
          public mutating func clearRelease() {_uniqueStorage()._release = nil}

          public var status: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.VirtualMachineStatus {
            get {_storage._status}
            set {_uniqueStorage()._status = newValue}
          }

          public var mounts: [String] {
            get {_storage._mounts}
            set {_uniqueStorage()._mounts = newValue}
          }

          public var name: String {
            get {_storage._name}
            set {_uniqueStorage()._name = newValue}
          }

          public var networks: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.AttachedNetwork] {
            get {_storage._networks}
            set {_uniqueStorage()._networks = newValue}
          }

          public var tunnels: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo] {
            get {_storage._tunnels}
            set {_uniqueStorage()._tunnels = newValue}
          }

          public var sockets: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.SocketInfo] {
            get {_storage._sockets}
            set {_uniqueStorage()._sockets = newValue}
          }

          public var cpu: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo {
            get {_storage._cpu ?? Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo()}
            set {_uniqueStorage()._cpu = newValue}
          }
          /// Returns true if `cpu` has been explicitly set.
          public var hasCpu: Bool {_storage._cpu != nil}
          /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
          public mutating func clearCpu() {_uniqueStorage()._cpu = nil}

          public var vncURL: String {
            get {_storage._vncURL ?? String()}
            set {_uniqueStorage()._vncURL = newValue}
          }
          /// Returns true if `vncURL` has been explicitly set.
          public var hasVncURL: Bool {_storage._vncURL != nil}
          /// Clears the value of `vncURL`. Subsequent reads from it will return its default value.
          public mutating func clearVncURL() {_uniqueStorage()._vncURL = nil}

          public var agentVersion: String {
            get {_storage._agentVersion}
            set {_uniqueStorage()._agentVersion = newValue}
          }

          public var reason: String {
            get {_storage._reason ?? String()}
            set {_uniqueStorage()._reason = newValue}
          }
          /// Returns true if `reason` has been explicitly set.
          public var hasReason: Bool {_storage._reason != nil}
          /// Clears the value of `reason`. Subsequent reads from it will return its default value.
          public mutating func clearReason() {_uniqueStorage()._reason = nil}

          public var success: Bool {
            get {_storage._success}
            set {_uniqueStorage()._success = newValue}
          }

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum VirtualMachineStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
            public typealias RawValue = Int
            case stopped // = 0
            case running // = 1
            case paused // = 2
            case error // = 3
            case UNRECOGNIZED(Int)

            public init() {
              self = .stopped
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .stopped
              case 1: self = .running
              case 2: self = .paused
              case 3: self = .error
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .stopped: return 0
              case .running: return 1
              case .paused: return 2
              case .error: return 3
              case .UNRECOGNIZED(let i): return i
              }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            public static let allCases: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.VirtualMachineStatus] = [
              .stopped,
              .running,
              .paused,
              .error,
            ]

          }

          public struct CpuCoreInfo: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var coreID: Int32 = 0

            public var usagePercent: Double = 0

            public var user: Double = 0

            public var system: Double = 0

            public var idle: Double = 0

            public var iowait: Double = 0

            public var irq: Double = 0

            public var softirq: Double = 0

            public var steal: Double = 0

            public var guest: Double = 0

            public var guestNice: Double = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct CpuInfo: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var totalUsagePercent: Double = 0

            public var user: Double = 0

            public var system: Double = 0

            public var idle: Double = 0

            public var iowait: Double = 0

            public var irq: Double = 0

            public var softirq: Double = 0

            public var steal: Double = 0

            public var guest: Double = 0

            public var guestNice: Double = 0

            public var cores: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuCoreInfo] = []

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct MemoryInfo: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var total: UInt64 = 0

            public var free: UInt64 {
              get {_free ?? 0}
              set {_free = newValue}
            }
            /// Returns true if `free` has been explicitly set.
            public var hasFree: Bool {self._free != nil}
            /// Clears the value of `free`. Subsequent reads from it will return its default value.
            public mutating func clearFree() {self._free = nil}

            public var used: UInt64 {
              get {_used ?? 0}
              set {_used = newValue}
            }
            /// Returns true if `used` has been explicitly set.
            public var hasUsed: Bool {self._used != nil}
            /// Clears the value of `used`. Subsequent reads from it will return its default value.
            public mutating func clearUsed() {self._used = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}

            fileprivate var _free: UInt64? = nil
            fileprivate var _used: UInt64? = nil
          }

          public struct DiskInfo: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var device: String = String()

            public var mount: String = String()

            public var fsType: String = String()

            public var size: UInt64 = 0

            public var used: UInt64 = 0

            public var free: UInt64 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}
          }

          public struct AttachedNetwork: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var network: String = String()

            public var mode: String {
              get {_mode ?? String()}
              set {_mode = newValue}
            }
            /// Returns true if `mode` has been explicitly set.
            public var hasMode: Bool {self._mode != nil}
            /// Clears the value of `mode`. Subsequent reads from it will return its default value.
            public mutating func clearMode() {self._mode = nil}

            public var macAddress: String {
              get {_macAddress ?? String()}
              set {_macAddress = newValue}
            }
            /// Returns true if `macAddress` has been explicitly set.
            public var hasMacAddress: Bool {self._macAddress != nil}
            /// Clears the value of `macAddress`. Subsequent reads from it will return its default value.
            public mutating func clearMacAddress() {self._macAddress = nil}

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public init() {}

            fileprivate var _mode: String? = nil
            fileprivate var _macAddress: String? = nil
          }

          public struct TunnelInfo: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var tunnel: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.OneOf_Tunnel? = nil

            public var forward: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ForwardedPort {
              get {
                if case .forward(let v)? = tunnel {return v}
                return Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ForwardedPort()
              }
              set {tunnel = .forward(newValue)}
            }

            public var unixDomain: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.Tunnel {
              get {
                if case .unixDomain(let v)? = tunnel {return v}
                return Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.Tunnel()
              }
              set {tunnel = .unixDomain(newValue)}
            }

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum OneOf_Tunnel: Equatable, Sendable {
              case forward(Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ForwardedPort)
              case unixDomain(Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.Tunnel)

            }

            public enum ProtocolEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
              public typealias RawValue = Int
              case tcp // = 0
              case udp // = 1
              case UNRECOGNIZED(Int)

              public init() {
                self = .tcp
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .tcp
                case 1: self = .udp
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .tcp: return 0
                case .udp: return 1
                case .UNRECOGNIZED(let i): return i
                }
              }

              // The compiler won't synthesize support with the UNRECOGNIZED case.
              public static let allCases: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ProtocolEnum] = [
                .tcp,
                .udp,
              ]

            }

            public struct ForwardedPort: Sendable {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var `protocol`: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ProtocolEnum = .tcp

              public var host: Int32 = 0

              public var guest: Int32 = 0

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public init() {}
            }

            public struct Tunnel: Sendable {
              // SwiftProtobuf.Message conformance is added in an extension below. See the
              // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
              // methods supported on all messages.

              public var `protocol`: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ProtocolEnum = .tcp

              public var host: String = String()

              public var guest: String = String()

              public var unknownFields = SwiftProtobuf.UnknownStorage()

              public init() {}
            }

            public init() {}
          }

          public struct SocketInfo: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            public var mode: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.SocketInfo.Mode = .bind

            public var host: String = String()

            public var port: Int32 = 0

            public var unknownFields = SwiftProtobuf.UnknownStorage()

            public enum Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
              public typealias RawValue = Int
              case bind // = 0
              case connect // = 1
              case tcp // = 2
              case udp // = 3
              case UNRECOGNIZED(Int)

              public init() {
                self = .bind
              }

              public init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .bind
                case 1: self = .connect
                case 2: self = .tcp
                case 3: self = .udp
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              public var rawValue: Int {
                switch self {
                case .bind: return 0
                case .connect: return 1
                case .tcp: return 2
                case .udp: return 3
                case .UNRECOGNIZED(let i): return i
                }
              }

              // The compiler won't synthesize support with the UNRECOGNIZED case.
              public static let allCases: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.SocketInfo.Mode] = [
                .bind,
                .connect,
                .tcp,
                .udp,
              ]

            }

            public init() {}
          }

          public init() {}

          fileprivate var _storage = _StorageClass.defaultInstance
        }

        public init() {}

        fileprivate var _status: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply? = nil
        fileprivate var _reason: String? = nil
      }

      public struct LaunchReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var address: String {
          get {_address ?? String()}
          set {_address = newValue}
        }
        /// Returns true if `address` has been explicitly set.
        public var hasAddress: Bool {self._address != nil}
        /// Clears the value of `address`. Subsequent reads from it will return its default value.
        public mutating func clearAddress() {self._address = nil}

        public var launched: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _address: String? = nil
        fileprivate var _reason: String? = nil
      }

      public struct StartedReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var address: String {
          get {_address ?? String()}
          set {_address = newValue}
        }
        /// Returns true if `address` has been explicitly set.
        public var hasAddress: Bool {self._address != nil}
        /// Clears the value of `address`. Subsequent reads from it will return its default value.
        public mutating func clearAddress() {self._address = nil}

        public var started: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _address: String? = nil
        fileprivate var _reason: String? = nil
      }

      public struct BuildedReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var builded: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct BuildProgressValue: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var oldFractionCompleted: Double = 0

        public var fractionCompleted: Double = 0

        public var lastCompleted10: Int32 = 0

        public var lastCompleted2: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct BuildTerminatedReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var result: Caked_Caked.Reply.VirtualMachineReply.BuildTerminatedReply.OneOf_Result? = nil

        public var success: String {
          get {
            if case .success(let v)? = result {return v}
            return String()
          }
          set {result = .success(newValue)}
        }

        public var failure: String {
          get {
            if case .failure(let v)? = result {return v}
            return String()
          }
          set {result = .failure(newValue)}
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Result: Equatable, Sendable {
          case success(String)
          case failure(String)

        }

        public init() {}
      }

      public struct BuildStreamReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var current: Caked_Caked.Reply.VirtualMachineReply.BuildStreamReply.OneOf_Current? = nil

        public var progress: Caked_Caked.Reply.VirtualMachineReply.BuildProgressValue {
          get {
            if case .progress(let v)? = current {return v}
            return Caked_Caked.Reply.VirtualMachineReply.BuildProgressValue()
          }
          set {current = .progress(newValue)}
        }

        public var terminated: Caked_Caked.Reply.VirtualMachineReply.BuildTerminatedReply {
          get {
            if case .terminated(let v)? = current {return v}
            return Caked_Caked.Reply.VirtualMachineReply.BuildTerminatedReply()
          }
          set {current = .terminated(newValue)}
        }

        public var step: String {
          get {
            if case .step(let v)? = current {return v}
            return String()
          }
          set {current = .step(newValue)}
        }

        public var builded: Caked_Caked.Reply.VirtualMachineReply.BuildedReply {
          get {
            if case .builded(let v)? = current {return v}
            return Caked_Caked.Reply.VirtualMachineReply.BuildedReply()
          }
          set {current = .builded(newValue)}
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_Current: Equatable, Sendable {
          case progress(Caked_Caked.Reply.VirtualMachineReply.BuildProgressValue)
          case terminated(Caked_Caked.Reply.VirtualMachineReply.BuildTerminatedReply)
          case step(String)
          case builded(Caked_Caked.Reply.VirtualMachineReply.BuildedReply)

        }

        public init() {}
      }

      public struct ClonedReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var sourceName: String = String()

        public var targetName: String = String()

        public var cloned: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct ConfiguredReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var configured: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct DuplicatedReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var from: String = String()

        public var to: String = String()

        public var duplicated: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct ImportedReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var source: String = String()

        public var imported: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct WaitIPReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var ip: String = String()

        public var success: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct PurgeReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var purged: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct RenameReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var oldName: String = String()

        public var newName: String = String()

        public var renamed: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public init() {}
    }

    public struct ImageReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Caked_Caked.Reply.ImageReply.OneOf_Response? = nil

      public var infos: Caked_Caked.Reply.ImageReply.ImageInfoReply {
        get {
          if case .infos(let v)? = response {return v}
          return Caked_Caked.Reply.ImageReply.ImageInfoReply()
        }
        set {response = .infos(newValue)}
      }

      public var pull: Caked_Caked.Reply.ImageReply.PulledImageInfoReply {
        get {
          if case .pull(let v)? = response {return v}
          return Caked_Caked.Reply.ImageReply.PulledImageInfoReply()
        }
        set {response = .pull(newValue)}
      }

      public var list: Caked_Caked.Reply.ImageReply.ListImagesInfoReply {
        get {
          if case .list(let v)? = response {return v}
          return Caked_Caked.Reply.ImageReply.ListImagesInfoReply()
        }
        set {response = .list(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case infos(Caked_Caked.Reply.ImageReply.ImageInfoReply)
        case pull(Caked_Caked.Reply.ImageReply.PulledImageInfoReply)
        case list(Caked_Caked.Reply.ImageReply.ListImagesInfoReply)

      }

      public struct ImageInfo: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var aliases: [String] = []

        public var architecture: String = String()

        public var pub: Bool = false

        public var fileName: String = String()

        public var fingerprint: String = String()

        public var size: UInt64 = 0

        public var type: String = String()

        public var created: String {
          get {_created ?? String()}
          set {_created = newValue}
        }
        /// Returns true if `created` has been explicitly set.
        public var hasCreated: Bool {self._created != nil}
        /// Clears the value of `created`. Subsequent reads from it will return its default value.
        public mutating func clearCreated() {self._created = nil}

        public var expires: String {
          get {_expires ?? String()}
          set {_expires = newValue}
        }
        /// Returns true if `expires` has been explicitly set.
        public var hasExpires: Bool {self._expires != nil}
        /// Clears the value of `expires`. Subsequent reads from it will return its default value.
        public mutating func clearExpires() {self._expires = nil}

        public var uploaded: String {
          get {_uploaded ?? String()}
          set {_uploaded = newValue}
        }
        /// Returns true if `uploaded` has been explicitly set.
        public var hasUploaded: Bool {self._uploaded != nil}
        /// Clears the value of `uploaded`. Subsequent reads from it will return its default value.
        public mutating func clearUploaded() {self._uploaded = nil}

        public var properties: Dictionary<String,String> = [:]

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _created: String? = nil
        fileprivate var _expires: String? = nil
        fileprivate var _uploaded: String? = nil
      }

      public struct ListImagesInfoReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var success: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var infos: [Caked_Caked.Reply.ImageReply.ImageInfo] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct ImageInfoReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var info: Caked_Caked.Reply.ImageReply.ImageInfo {
          get {_info ?? Caked_Caked.Reply.ImageReply.ImageInfo()}
          set {_info = newValue}
        }
        /// Returns true if `info` has been explicitly set.
        public var hasInfo: Bool {self._info != nil}
        /// Clears the value of `info`. Subsequent reads from it will return its default value.
        public mutating func clearInfo() {self._info = nil}

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var success: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _info: Caked_Caked.Reply.ImageReply.ImageInfo? = nil
        fileprivate var _reason: String? = nil
      }

      public struct PulledImageInfoReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var info: Caked_Caked.Reply.ImageReply.PulledImageInfoReply.PulledImageInfo {
          get {_info ?? Caked_Caked.Reply.ImageReply.PulledImageInfoReply.PulledImageInfo()}
          set {_info = newValue}
        }
        /// Returns true if `info` has been explicitly set.
        public var hasInfo: Bool {self._info != nil}
        /// Clears the value of `info`. Subsequent reads from it will return its default value.
        public mutating func clearInfo() {self._info = nil}

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var success: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct PulledImageInfo: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var alias: String {
            get {_alias ?? String()}
            set {_alias = newValue}
          }
          /// Returns true if `alias` has been explicitly set.
          public var hasAlias: Bool {self._alias != nil}
          /// Clears the value of `alias`. Subsequent reads from it will return its default value.
          public mutating func clearAlias() {self._alias = nil}

          public var path: String = String()

          public var size: UInt64 = 0

          public var fingerprint: String = String()

          public var remoteName: String = String()

          public var description_p: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}

          fileprivate var _alias: String? = nil
        }

        public init() {}

        fileprivate var _info: Caked_Caked.Reply.ImageReply.PulledImageInfoReply.PulledImageInfo? = nil
        fileprivate var _reason: String? = nil
      }

      public init() {}
    }

    public struct NetworksReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Caked_Caked.Reply.NetworksReply.OneOf_Response? = nil

      public var list: Caked_Caked.Reply.NetworksReply.ListNetworksReply {
        get {
          if case .list(let v)? = response {return v}
          return Caked_Caked.Reply.NetworksReply.ListNetworksReply()
        }
        set {response = .list(newValue)}
      }

      public var status: Caked_Caked.Reply.NetworksReply.NetworkInfoReply {
        get {
          if case .status(let v)? = response {return v}
          return Caked_Caked.Reply.NetworksReply.NetworkInfoReply()
        }
        set {response = .status(newValue)}
      }

      public var created: Caked_Caked.Reply.NetworksReply.CreatedNetworkReply {
        get {
          if case .created(let v)? = response {return v}
          return Caked_Caked.Reply.NetworksReply.CreatedNetworkReply()
        }
        set {response = .created(newValue)}
      }

      public var configured: Caked_Caked.Reply.NetworksReply.ConfiguredNetworkReply {
        get {
          if case .configured(let v)? = response {return v}
          return Caked_Caked.Reply.NetworksReply.ConfiguredNetworkReply()
        }
        set {response = .configured(newValue)}
      }

      public var delete: Caked_Caked.Reply.NetworksReply.DeleteNetworkReply {
        get {
          if case .delete(let v)? = response {return v}
          return Caked_Caked.Reply.NetworksReply.DeleteNetworkReply()
        }
        set {response = .delete(newValue)}
      }

      public var started: Caked_Caked.Reply.NetworksReply.StartedNetworkReply {
        get {
          if case .started(let v)? = response {return v}
          return Caked_Caked.Reply.NetworksReply.StartedNetworkReply()
        }
        set {response = .started(newValue)}
      }

      public var stopped: Caked_Caked.Reply.NetworksReply.StoppedNetworkReply {
        get {
          if case .stopped(let v)? = response {return v}
          return Caked_Caked.Reply.NetworksReply.StoppedNetworkReply()
        }
        set {response = .stopped(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case list(Caked_Caked.Reply.NetworksReply.ListNetworksReply)
        case status(Caked_Caked.Reply.NetworksReply.NetworkInfoReply)
        case created(Caked_Caked.Reply.NetworksReply.CreatedNetworkReply)
        case configured(Caked_Caked.Reply.NetworksReply.ConfiguredNetworkReply)
        case delete(Caked_Caked.Reply.NetworksReply.DeleteNetworkReply)
        case started(Caked_Caked.Reply.NetworksReply.StartedNetworkReply)
        case stopped(Caked_Caked.Reply.NetworksReply.StoppedNetworkReply)

      }

      public struct NetworkInfo: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var mode: String = String()

        public var description_p: String = String()

        public var gateway: String = String()

        public var dhcpEnd: String = String()

        public var netmask: String = String()

        public var interfaceID: String = String()

        public var endpoint: String = String()

        public var used: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct NetworkInfoReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var info: Caked_Caked.Reply.NetworksReply.NetworkInfo {
          get {_info ?? Caked_Caked.Reply.NetworksReply.NetworkInfo()}
          set {_info = newValue}
        }
        /// Returns true if `info` has been explicitly set.
        public var hasInfo: Bool {self._info != nil}
        /// Clears the value of `info`. Subsequent reads from it will return its default value.
        public mutating func clearInfo() {self._info = nil}

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var success: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _info: Caked_Caked.Reply.NetworksReply.NetworkInfo? = nil
        fileprivate var _reason: String? = nil
      }

      public struct ListNetworksReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var networks: [Caked_Caked.Reply.NetworksReply.NetworkInfo] = []

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var success: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct StartedNetworkReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var started: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct StoppedNetworkReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var stopped: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct CreatedNetworkReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var created: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct ConfiguredNetworkReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var configured: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct DeleteNetworkReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var deleted: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public init() {}
    }

    public struct RemoteReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Caked_Caked.Reply.RemoteReply.OneOf_Response? = nil

      public var list: Caked_Caked.Reply.RemoteReply.ListRemoteReply {
        get {
          if case .list(let v)? = response {return v}
          return Caked_Caked.Reply.RemoteReply.ListRemoteReply()
        }
        set {response = .list(newValue)}
      }

      public var deleted: Caked_Caked.Reply.RemoteReply.DeleteRemoteReply {
        get {
          if case .deleted(let v)? = response {return v}
          return Caked_Caked.Reply.RemoteReply.DeleteRemoteReply()
        }
        set {response = .deleted(newValue)}
      }

      public var created: Caked_Caked.Reply.RemoteReply.CreateRemoteReply {
        get {
          if case .created(let v)? = response {return v}
          return Caked_Caked.Reply.RemoteReply.CreateRemoteReply()
        }
        set {response = .created(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case list(Caked_Caked.Reply.RemoteReply.ListRemoteReply)
        case deleted(Caked_Caked.Reply.RemoteReply.DeleteRemoteReply)
        case created(Caked_Caked.Reply.RemoteReply.CreateRemoteReply)

      }

      public struct ListRemoteReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var remotes: [Caked_Caked.Reply.RemoteReply.ListRemoteReply.RemoteEntry] = []

        public var success: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct RemoteEntry: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var name: String = String()

          public var url: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct DeleteRemoteReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var deleted: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct CreateRemoteReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var created: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public init() {}
    }

    public struct TemplateReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Caked_Caked.Reply.TemplateReply.OneOf_Response? = nil

      public var list: Caked_Caked.Reply.TemplateReply.ListTemplatesReply {
        get {
          if case .list(let v)? = response {return v}
          return Caked_Caked.Reply.TemplateReply.ListTemplatesReply()
        }
        set {response = .list(newValue)}
      }

      public var create: Caked_Caked.Reply.TemplateReply.CreateTemplateReply {
        get {
          if case .create(let v)? = response {return v}
          return Caked_Caked.Reply.TemplateReply.CreateTemplateReply()
        }
        set {response = .create(newValue)}
      }

      public var delete: Caked_Caked.Reply.TemplateReply.DeleteTemplateReply {
        get {
          if case .delete(let v)? = response {return v}
          return Caked_Caked.Reply.TemplateReply.DeleteTemplateReply()
        }
        set {response = .delete(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case list(Caked_Caked.Reply.TemplateReply.ListTemplatesReply)
        case create(Caked_Caked.Reply.TemplateReply.CreateTemplateReply)
        case delete(Caked_Caked.Reply.TemplateReply.DeleteTemplateReply)

      }

      public struct ListTemplatesReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var templates: [Caked_Caked.Reply.TemplateReply.ListTemplatesReply.TemplateEntry] = []

        public var success: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct TemplateEntry: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var name: String = String()

          public var fqn: String = String()

          public var diskSize: UInt64 = 0

          public var totalSize: UInt64 = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct CreateTemplateReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var created: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public struct DeleteTemplateReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var deleted: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public init() {}
    }

    public struct RunReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var exitCode: Int32 = 0

      public var stdout: Data = Data()

      public var stderr: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct MountReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var success: Bool = false

      public var reason: String {
        get {_reason ?? String()}
        set {_reason = newValue}
      }
      /// Returns true if `reason` has been explicitly set.
      public var hasReason: Bool {self._reason != nil}
      /// Clears the value of `reason`. Subsequent reads from it will return its default value.
      public mutating func clearReason() {self._reason = nil}

      public var mounts: [Caked_Caked.Reply.MountReply.MountVirtioFSReply] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct MountVirtioFSReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var mounted: Bool = false

        public var reason: String {
          get {_reason ?? String()}
          set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        public var hasReason: Bool {self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        public mutating func clearReason() {self._reason = nil}

        public var name: String = String()

        public var path: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _reason: String? = nil
      }

      public init() {}

      fileprivate var _reason: String? = nil
    }

    public struct OCIReply: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Caked_Caked.Reply.OCIReply.OneOf_Response? = nil

      public var login: Caked_Caked.Reply.OCIReply.LoginReply {
        get {
          if case .login(let v)? = response {return v}
          return Caked_Caked.Reply.OCIReply.LoginReply()
        }
        set {response = .login(newValue)}
      }

      public var logout: Caked_Caked.Reply.OCIReply.LogoutReply {
        get {
          if case .logout(let v)? = response {return v}
          return Caked_Caked.Reply.OCIReply.LogoutReply()
        }
        set {response = .logout(newValue)}
      }

      public var pull: Caked_Caked.Reply.OCIReply.PullReply {
        get {
          if case .pull(let v)? = response {return v}
          return Caked_Caked.Reply.OCIReply.PullReply()
        }
        set {response = .pull(newValue)}
      }

      public var push: Caked_Caked.Reply.OCIReply.PushReply {
        get {
          if case .push(let v)? = response {return v}
          return Caked_Caked.Reply.OCIReply.PushReply()
        }
        set {response = .push(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case login(Caked_Caked.Reply.OCIReply.LoginReply)
        case logout(Caked_Caked.Reply.OCIReply.LogoutReply)
        case pull(Caked_Caked.Reply.OCIReply.PullReply)
        case push(Caked_Caked.Reply.OCIReply.PushReply)

      }

      public struct PullReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var success: Bool = false

        public var message: String = String()

        public var imageType: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct PushReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var success: Bool = false

        public var message: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct LoginReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var success: Bool = false

        public var message: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct LogoutReply: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var success: Bool = false

        public var message: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public struct NetworkRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var command: Caked_Caked.NetworkRequest.NetworkCommand = .infos

    public var network: Caked_Caked.NetworkRequest.OneOf_Network? = nil

    public var name: String {
      get {
        if case .name(let v)? = network {return v}
        return String()
      }
      set {network = .name(newValue)}
    }

    public var create: Caked_Caked.NetworkRequest.CreateNetworkRequest {
      get {
        if case .create(let v)? = network {return v}
        return Caked_Caked.NetworkRequest.CreateNetworkRequest()
      }
      set {network = .create(newValue)}
    }

    public var configure: Caked_Caked.NetworkRequest.ConfigureNetworkRequest {
      get {
        if case .configure(let v)? = network {return v}
        return Caked_Caked.NetworkRequest.ConfigureNetworkRequest()
      }
      set {network = .configure(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Network: Equatable, Sendable {
      case name(String)
      case create(Caked_Caked.NetworkRequest.CreateNetworkRequest)
      case configure(Caked_Caked.NetworkRequest.ConfigureNetworkRequest)

    }

    public enum NetworkMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case shared // = 0
      case host // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .shared
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .shared
        case 1: self = .host
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .shared: return 0
        case .host: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Caked_Caked.NetworkRequest.NetworkMode] = [
        .shared,
        .host,
      ]

    }

    public enum NetworkCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case infos // = 0
      case new // = 1
      case set // = 2
      case start // = 3
      case shutdown // = 4
      case remove // = 5
      case status // = 6
      case UNRECOGNIZED(Int)

      public init() {
        self = .infos
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .infos
        case 1: self = .new
        case 2: self = .set
        case 3: self = .start
        case 4: self = .shutdown
        case 5: self = .remove
        case 6: self = .status
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .infos: return 0
        case .new: return 1
        case .set: return 2
        case .start: return 3
        case .shutdown: return 4
        case .remove: return 5
        case .status: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Caked_Caked.NetworkRequest.NetworkCommand] = [
        .infos,
        .new,
        .set,
        .start,
        .shutdown,
        .remove,
        .status,
      ]

    }

    public struct ConfigureNetworkRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var gateway: String {
        get {_gateway ?? String()}
        set {_gateway = newValue}
      }
      /// Returns true if `gateway` has been explicitly set.
      public var hasGateway: Bool {self._gateway != nil}
      /// Clears the value of `gateway`. Subsequent reads from it will return its default value.
      public mutating func clearGateway() {self._gateway = nil}

      public var dhcpEnd: String {
        get {_dhcpEnd ?? String()}
        set {_dhcpEnd = newValue}
      }
      /// Returns true if `dhcpEnd` has been explicitly set.
      public var hasDhcpEnd: Bool {self._dhcpEnd != nil}
      /// Clears the value of `dhcpEnd`. Subsequent reads from it will return its default value.
      public mutating func clearDhcpEnd() {self._dhcpEnd = nil}

      public var netmask: String {
        get {_netmask ?? String()}
        set {_netmask = newValue}
      }
      /// Returns true if `netmask` has been explicitly set.
      public var hasNetmask: Bool {self._netmask != nil}
      /// Clears the value of `netmask`. Subsequent reads from it will return its default value.
      public mutating func clearNetmask() {self._netmask = nil}

      public var uuid: String {
        get {_uuid ?? String()}
        set {_uuid = newValue}
      }
      /// Returns true if `uuid` has been explicitly set.
      public var hasUuid: Bool {self._uuid != nil}
      /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
      public mutating func clearUuid() {self._uuid = nil}

      public var nat66Prefix: String {
        get {_nat66Prefix ?? String()}
        set {_nat66Prefix = newValue}
      }
      /// Returns true if `nat66Prefix` has been explicitly set.
      public var hasNat66Prefix: Bool {self._nat66Prefix != nil}
      /// Clears the value of `nat66Prefix`. Subsequent reads from it will return its default value.
      public mutating func clearNat66Prefix() {self._nat66Prefix = nil}

      public var dhcpLease: Int32 {
        get {_dhcpLease ?? 0}
        set {_dhcpLease = newValue}
      }
      /// Returns true if `dhcpLease` has been explicitly set.
      public var hasDhcpLease: Bool {self._dhcpLease != nil}
      /// Clears the value of `dhcpLease`. Subsequent reads from it will return its default value.
      public mutating func clearDhcpLease() {self._dhcpLease = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _gateway: String? = nil
      fileprivate var _dhcpEnd: String? = nil
      fileprivate var _netmask: String? = nil
      fileprivate var _uuid: String? = nil
      fileprivate var _nat66Prefix: String? = nil
      fileprivate var _dhcpLease: Int32? = nil
    }

    public struct CreateNetworkRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var mode: Caked_Caked.NetworkRequest.NetworkMode = .shared

      public var name: String = String()

      public var gateway: String = String()

      public var dhcpEnd: String = String()

      public var netmask: String = String()

      public var uuid: String {
        get {_uuid ?? String()}
        set {_uuid = newValue}
      }
      /// Returns true if `uuid` has been explicitly set.
      public var hasUuid: Bool {self._uuid != nil}
      /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
      public mutating func clearUuid() {self._uuid = nil}

      public var nat66Prefix: String {
        get {_nat66Prefix ?? String()}
        set {_nat66Prefix = newValue}
      }
      /// Returns true if `nat66Prefix` has been explicitly set.
      public var hasNat66Prefix: Bool {self._nat66Prefix != nil}
      /// Clears the value of `nat66Prefix`. Subsequent reads from it will return its default value.
      public mutating func clearNat66Prefix() {self._nat66Prefix = nil}

      public var dhcpLease: Int32 {
        get {_dhcpLease ?? 0}
        set {_dhcpLease = newValue}
      }
      /// Returns true if `dhcpLease` has been explicitly set.
      public var hasDhcpLease: Bool {self._dhcpLease != nil}
      /// Clears the value of `dhcpLease`. Subsequent reads from it will return its default value.
      public mutating func clearDhcpLease() {self._dhcpLease = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _uuid: String? = nil
      fileprivate var _nat66Prefix: String? = nil
      fileprivate var _dhcpLease: Int32? = nil
    }

    public init() {}
  }

  public struct ImageRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var command: Caked_Caked.ImageRequest.ImageCommand = .none

    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ImageCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case none // = 0
      case info // = 1
      case pull // = 2
      case list // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .info
        case 2: self = .pull
        case 3: self = .list
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .info: return 1
        case .pull: return 2
        case .list: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Caked_Caked.ImageRequest.ImageCommand] = [
        .none,
        .info,
        .pull,
        .list,
      ]

    }

    public init() {}
  }

  public struct RemoteRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var command: Caked_Caked.RemoteRequest.RemoteCommand = .none

    public var remote: Caked_Caked.RemoteRequest.OneOf_Remote? = nil

    public var addRequest: Caked_Caked.RemoteRequest.RemoteRequestAdd {
      get {
        if case .addRequest(let v)? = remote {return v}
        return Caked_Caked.RemoteRequest.RemoteRequestAdd()
      }
      set {remote = .addRequest(newValue)}
    }

    public var deleteRequest: String {
      get {
        if case .deleteRequest(let v)? = remote {return v}
        return String()
      }
      set {remote = .deleteRequest(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Remote: Equatable, Sendable {
      case addRequest(Caked_Caked.RemoteRequest.RemoteRequestAdd)
      case deleteRequest(String)

    }

    public enum RemoteCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case none // = 0
      case list // = 1
      case add // = 2
      case delete // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .list
        case 2: self = .add
        case 3: self = .delete
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .list: return 1
        case .add: return 2
        case .delete: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Caked_Caked.RemoteRequest.RemoteCommand] = [
        .none,
        .list,
        .add,
        .delete,
      ]

    }

    public struct RemoteRequestAdd: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var url: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct PurgeRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var entries: String {
      get {_entries ?? String()}
      set {_entries = newValue}
    }
    /// Returns true if `entries` has been explicitly set.
    public var hasEntries: Bool {self._entries != nil}
    /// Clears the value of `entries`. Subsequent reads from it will return its default value.
    public mutating func clearEntries() {self._entries = nil}

    public var olderThan: Int32 {
      get {_olderThan ?? 0}
      set {_olderThan = newValue}
    }
    /// Returns true if `olderThan` has been explicitly set.
    public var hasOlderThan: Bool {self._olderThan != nil}
    /// Clears the value of `olderThan`. Subsequent reads from it will return its default value.
    public mutating func clearOlderThan() {self._olderThan = nil}

    public var spaceBudget: Int32 {
      get {_spaceBudget ?? 0}
      set {_spaceBudget = newValue}
    }
    /// Returns true if `spaceBudget` has been explicitly set.
    public var hasSpaceBudget: Bool {self._spaceBudget != nil}
    /// Clears the value of `spaceBudget`. Subsequent reads from it will return its default value.
    public mutating func clearSpaceBudget() {self._spaceBudget = nil}

    public var gc: Bool {
      get {_gc ?? false}
      set {_gc = newValue}
    }
    /// Returns true if `gc` has been explicitly set.
    public var hasGc: Bool {self._gc != nil}
    /// Clears the value of `gc`. Subsequent reads from it will return its default value.
    public mutating func clearGc() {self._gc = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entries: String? = nil
    fileprivate var _olderThan: Int32? = nil
    fileprivate var _spaceBudget: Int32? = nil
    fileprivate var _gc: Bool? = nil
  }

  public struct PushRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var localName: String = String()

    public var remoteNames: [String] = []

    public var insecure: Bool = false

    public var chunkSize: Int32 = 0

    public var concurrency: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct CloneRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var image: String = String()

    public var insecure: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct LoginRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var host: String = String()

    public var username: String = String()

    public var password: String = String()

    public var insecure: Bool = false

    public var noValidate: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct LogoutRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var host: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MountRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var command: Caked_Caked.MountRequest.MountCommand = .none

    public var name: String = String()

    public var mounts: [Caked_Caked.MountRequest.MountVirtioFS] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum MountCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case none // = 0
      case mount // = 1
      case umount // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .none
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .mount
        case 2: self = .umount
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .none: return 0
        case .mount: return 1
        case .umount: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Caked_Caked.MountRequest.MountCommand] = [
        .none,
        .mount,
        .umount,
      ]

    }

    public struct MountVirtioFS: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var source: String = String()

      public var target: String {
        get {_target ?? String()}
        set {_target = newValue}
      }
      /// Returns true if `target` has been explicitly set.
      public var hasTarget: Bool {self._target != nil}
      /// Clears the value of `target`. Subsequent reads from it will return its default value.
      public mutating func clearTarget() {self._target = nil}

      public var name: String {
        get {_name ?? String()}
        set {_name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      public var hasName: Bool {self._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      public mutating func clearName() {self._name = nil}

      public var uid: Int32 {
        get {_uid ?? 0}
        set {_uid = newValue}
      }
      /// Returns true if `uid` has been explicitly set.
      public var hasUid: Bool {self._uid != nil}
      /// Clears the value of `uid`. Subsequent reads from it will return its default value.
      public mutating func clearUid() {self._uid = nil}

      public var gid: Int32 {
        get {_gid ?? 0}
        set {_gid = newValue}
      }
      /// Returns true if `gid` has been explicitly set.
      public var hasGid: Bool {self._gid != nil}
      /// Clears the value of `gid`. Subsequent reads from it will return its default value.
      public mutating func clearGid() {self._gid = nil}

      public var readonly: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _target: String? = nil
      fileprivate var _name: String? = nil
      fileprivate var _uid: Int32? = nil
      fileprivate var _gid: Int32? = nil
    }

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "caked"

extension Caked_Caked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Caked"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked, rhs: Caked_Caked) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".PingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}message\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.PingRequest, rhs: Caked_Caked.PingRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.message != rhs.message {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.CurrentStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".CurrentStatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}frequency\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.frequency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.frequency != 0 {
      try visitor.visitSingularInt32Field(value: self.frequency, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.CurrentStatusRequest, rhs: Caked_Caked.CurrentStatusRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.frequency != rhs.frequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".VMRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest, rhs: Caked_Caked.VMRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.CommonBuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".CommonBuildRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}cpu\0\u{1}memory\0\u{1}user\0\u{1}mainGroup\0\u{1}sshPwAuth\0\u{1}image\0\u{1}sshAuthorizedKey\0\u{1}vendorData\0\u{1}userData\0\u{1}networkConfig\0\u{1}diskSize\0\u{1}autostart\0\u{1}nested\0\u{1}forwardedPort\0\u{1}mounts\0\u{1}networks\0\u{1}sockets\0\u{1}console\0\u{1}attachedDisks\0\u{1}dynamicPortForwarding\0\u{1}password\0\u{1}ifnames\0\u{1}suspendable\0\u{1}screenSize\0\u{1}displayRefit\0\u{1}otherGroups\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _cpu: Int32? = nil
    var _memory: Int32? = nil
    var _user: String? = nil
    var _password: String? = nil
    var _mainGroup: String? = nil
    var _sshPwAuth: Bool? = nil
    var _image: String? = nil
    var _sshAuthorizedKey: Data? = nil
    var _vendorData: Data? = nil
    var _userData: Data? = nil
    var _networkConfig: Data? = nil
    var _diskSize: Int32? = nil
    var _autostart: Bool? = nil
    var _nested: Bool? = nil
    var _forwardedPort: String? = nil
    var _mounts: String? = nil
    var _networks: String? = nil
    var _sockets: String? = nil
    var _console: String? = nil
    var _attachedDisks: String? = nil
    var _dynamicPortForwarding: Bool? = nil
    var _ifnames: Bool? = nil
    var _suspendable: Bool? = nil
    var _screenSize: Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize? = nil
    var _displayRefit: Bool? = nil
    var _otherGroups: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _cpu = source._cpu
      _memory = source._memory
      _user = source._user
      _password = source._password
      _mainGroup = source._mainGroup
      _sshPwAuth = source._sshPwAuth
      _image = source._image
      _sshAuthorizedKey = source._sshAuthorizedKey
      _vendorData = source._vendorData
      _userData = source._userData
      _networkConfig = source._networkConfig
      _diskSize = source._diskSize
      _autostart = source._autostart
      _nested = source._nested
      _forwardedPort = source._forwardedPort
      _mounts = source._mounts
      _networks = source._networks
      _sockets = source._sockets
      _console = source._console
      _attachedDisks = source._attachedDisks
      _dynamicPortForwarding = source._dynamicPortForwarding
      _ifnames = source._ifnames
      _suspendable = source._suspendable
      _screenSize = source._screenSize
      _displayRefit = source._displayRefit
      _otherGroups = source._otherGroups
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._cpu) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._memory) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._mainGroup) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._sshPwAuth) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._image) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._sshAuthorizedKey) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._vendorData) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._userData) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._networkConfig) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._diskSize) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._autostart) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._nested) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._forwardedPort) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._mounts) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._networks) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._sockets) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._console) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._attachedDisks) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._dynamicPortForwarding) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._password) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._ifnames) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._suspendable) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._screenSize) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._displayRefit) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._otherGroups) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._cpu {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memory {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._mainGroup {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sshPwAuth {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sshAuthorizedKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._vendorData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._userData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._networkConfig {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._diskSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._autostart {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._nested {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._forwardedPort {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._mounts {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._networks {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._sockets {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._console {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._attachedDisks {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._dynamicPortForwarding {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._password {
        try visitor.visitSingularStringField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._ifnames {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._suspendable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._screenSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._displayRefit {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._otherGroups {
        try visitor.visitSingularStringField(value: v, fieldNumber: 27)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.CommonBuildRequest, rhs: Caked_Caked.VMRequest.CommonBuildRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._password != rhs_storage._password {return false}
        if _storage._mainGroup != rhs_storage._mainGroup {return false}
        if _storage._sshPwAuth != rhs_storage._sshPwAuth {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._sshAuthorizedKey != rhs_storage._sshAuthorizedKey {return false}
        if _storage._vendorData != rhs_storage._vendorData {return false}
        if _storage._userData != rhs_storage._userData {return false}
        if _storage._networkConfig != rhs_storage._networkConfig {return false}
        if _storage._diskSize != rhs_storage._diskSize {return false}
        if _storage._autostart != rhs_storage._autostart {return false}
        if _storage._nested != rhs_storage._nested {return false}
        if _storage._forwardedPort != rhs_storage._forwardedPort {return false}
        if _storage._mounts != rhs_storage._mounts {return false}
        if _storage._networks != rhs_storage._networks {return false}
        if _storage._sockets != rhs_storage._sockets {return false}
        if _storage._console != rhs_storage._console {return false}
        if _storage._attachedDisks != rhs_storage._attachedDisks {return false}
        if _storage._dynamicPortForwarding != rhs_storage._dynamicPortForwarding {return false}
        if _storage._ifnames != rhs_storage._ifnames {return false}
        if _storage._suspendable != rhs_storage._suspendable {return false}
        if _storage._screenSize != rhs_storage._screenSize {return false}
        if _storage._displayRefit != rhs_storage._displayRefit {return false}
        if _storage._otherGroups != rhs_storage._otherGroups {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.CommonBuildRequest.protoMessageName + ".ScreenSize"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}width\0\u{1}height\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize, rhs: Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.BuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".BuildRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.BuildRequest, rhs: Caked_Caked.VMRequest.BuildRequest) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.StartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".StartRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}waitIPTimeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._waitIptimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._waitIptimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.StartRequest, rhs: Caked_Caked.VMRequest.StartRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._waitIptimeout != rhs._waitIptimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.CloneRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".CloneRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sourceName\0\u{1}targetName\0\u{1}insecure\0\u{1}concurrency\0\u{1}deduplicate\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._insecure) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._concurrency) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._deduplicate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceName, fieldNumber: 1)
    }
    if !self.targetName.isEmpty {
      try visitor.visitSingularStringField(value: self.targetName, fieldNumber: 2)
    }
    try { if let v = self._insecure {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._concurrency {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deduplicate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.CloneRequest, rhs: Caked_Caked.VMRequest.CloneRequest) -> Bool {
    if lhs.sourceName != rhs.sourceName {return false}
    if lhs.targetName != rhs.targetName {return false}
    if lhs._insecure != rhs._insecure {return false}
    if lhs._concurrency != rhs._concurrency {return false}
    if lhs._deduplicate != rhs._deduplicate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.DuplicateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".DuplicateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}from\0\u{1}to\0\u{1}resetMacAddress\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.resetMacAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    if self.resetMacAddress != false {
      try visitor.visitSingularBoolField(value: self.resetMacAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.DuplicateRequest, rhs: Caked_Caked.VMRequest.DuplicateRequest) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.resetMacAddress != rhs.resetMacAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.LaunchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".LaunchRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}options\0\u{1}waitIPTimeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._waitIptimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._waitIptimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.LaunchRequest, rhs: Caked_Caked.VMRequest.LaunchRequest) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs._waitIptimeout != rhs._waitIptimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.ConfigureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".ConfigureRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}cpu\0\u{1}memory\0\u{1}diskSize\0\u{1}displayRefit\0\u{1}autostart\0\u{1}nested\0\u{1}mounts\0\u{1}networks\0\u{1}sockets\0\u{1}console\0\u{1}randomMAC\0\u{1}forwardedPort\0\u{1}attachedDisks\0\u{1}dynamicPortForwarding\0\u{1}suspendable\0\u{1}screenSize\0\u{1}user\0\u{1}password\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _cpu: Int32? = nil
    var _memory: Int32? = nil
    var _diskSize: Int32? = nil
    var _displayRefit: Bool? = nil
    var _autostart: Bool? = nil
    var _nested: Bool? = nil
    var _mounts: String? = nil
    var _networks: String? = nil
    var _sockets: String? = nil
    var _console: String? = nil
    var _randomMac: Bool? = nil
    var _forwardedPort: String? = nil
    var _attachedDisks: String? = nil
    var _dynamicPortForwarding: Bool? = nil
    var _suspendable: Bool? = nil
    var _screenSize: Caked_Caked.VMRequest.CommonBuildRequest.ScreenSize? = nil
    var _user: String? = nil
    var _password: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _cpu = source._cpu
      _memory = source._memory
      _diskSize = source._diskSize
      _displayRefit = source._displayRefit
      _autostart = source._autostart
      _nested = source._nested
      _mounts = source._mounts
      _networks = source._networks
      _sockets = source._sockets
      _console = source._console
      _randomMac = source._randomMac
      _forwardedPort = source._forwardedPort
      _attachedDisks = source._attachedDisks
      _dynamicPortForwarding = source._dynamicPortForwarding
      _suspendable = source._suspendable
      _screenSize = source._screenSize
      _user = source._user
      _password = source._password
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._cpu) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._memory) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._diskSize) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._displayRefit) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._autostart) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._nested) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._mounts) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._networks) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._sockets) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._console) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._randomMac) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._forwardedPort) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._attachedDisks) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._dynamicPortForwarding) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._suspendable) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._screenSize) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._password) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._cpu {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memory {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._diskSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._displayRefit {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._autostart {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._nested {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._mounts {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._networks {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._sockets {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._console {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._randomMac {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._forwardedPort {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._attachedDisks {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._dynamicPortForwarding {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._suspendable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._screenSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._password {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.ConfigureRequest, rhs: Caked_Caked.VMRequest.ConfigureRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._diskSize != rhs_storage._diskSize {return false}
        if _storage._displayRefit != rhs_storage._displayRefit {return false}
        if _storage._autostart != rhs_storage._autostart {return false}
        if _storage._nested != rhs_storage._nested {return false}
        if _storage._mounts != rhs_storage._mounts {return false}
        if _storage._networks != rhs_storage._networks {return false}
        if _storage._sockets != rhs_storage._sockets {return false}
        if _storage._console != rhs_storage._console {return false}
        if _storage._randomMac != rhs_storage._randomMac {return false}
        if _storage._forwardedPort != rhs_storage._forwardedPort {return false}
        if _storage._attachedDisks != rhs_storage._attachedDisks {return false}
        if _storage._dynamicPortForwarding != rhs_storage._dynamicPortForwarding {return false}
        if _storage._suspendable != rhs_storage._suspendable {return false}
        if _storage._screenSize != rhs_storage._screenSize {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._password != rhs_storage._password {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.WaitIPRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".WaitIPRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt32Field(value: self.timeout, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.WaitIPRequest, rhs: Caked_Caked.VMRequest.WaitIPRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".StopRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}force\0\u{1}all\0\u{1}names\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.stop != nil {try decoder.handleConflictingOneOf()}
          self.stop = .all(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.VMRequest.StopRequest.VMNames?
        var hadOneofValue = false
        if let current = self.stop {
          hadOneofValue = true
          if case .names(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stop = .names(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 1)
    }
    switch self.stop {
    case .all?: try {
      guard case .all(let v)? = self.stop else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .names?: try {
      guard case .names(let v)? = self.stop else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.StopRequest, rhs: Caked_Caked.VMRequest.StopRequest) -> Bool {
    if lhs.force != rhs.force {return false}
    if lhs.stop != rhs.stop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.StopRequest.VMNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.StopRequest.protoMessageName + ".VMNames"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedStringField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.StopRequest.VMNames, rhs: Caked_Caked.VMRequest.StopRequest.VMNames) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.SuspendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".SuspendRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}names\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.names) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.SuspendRequest, rhs: Caked_Caked.VMRequest.SuspendRequest) -> Bool {
    if lhs.names != rhs.names {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.DeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".DeleteRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}all\0\u{1}names\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.delete != nil {try decoder.handleConflictingOneOf()}
          self.delete = .all(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.VMRequest.DeleteRequest.VMNames?
        var hadOneofValue = false
        if let current = self.delete {
          hadOneofValue = true
          if case .names(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.delete = .names(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.delete {
    case .all?: try {
      guard case .all(let v)? = self.delete else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .names?: try {
      guard case .names(let v)? = self.delete else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.DeleteRequest, rhs: Caked_Caked.VMRequest.DeleteRequest) -> Bool {
    if lhs.delete != rhs.delete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.DeleteRequest.VMNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.DeleteRequest.protoMessageName + ".VMNames"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedStringField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.DeleteRequest.VMNames, rhs: Caked_Caked.VMRequest.DeleteRequest.VMNames) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.ListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".ListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vmonly\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.vmonly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vmonly != false {
      try visitor.visitSingularBoolField(value: self.vmonly, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.ListRequest, rhs: Caked_Caked.VMRequest.ListRequest) -> Bool {
    if lhs.vmonly != rhs.vmonly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.InfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".InfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.InfoRequest, rhs: Caked_Caked.VMRequest.InfoRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.RenameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".RenameRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}oldname\0\u{1}newname\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oldname) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oldname.isEmpty {
      try visitor.visitSingularStringField(value: self.oldname, fieldNumber: 1)
    }
    if !self.newname.isEmpty {
      try visitor.visitSingularStringField(value: self.newname, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.RenameRequest, rhs: Caked_Caked.VMRequest.RenameRequest) -> Bool {
    if lhs.oldname != rhs.oldname {return false}
    if lhs.newname != rhs.newname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.TemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".TemplateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}createRequest\0\u{1}deleteRequest\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try {
        var v: Caked_Caked.VMRequest.TemplateRequest.TemplateRequestAdd?
        var hadOneofValue = false
        if let current = self.template {
          hadOneofValue = true
          if case .createRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.template = .createRequest(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.template != nil {try decoder.handleConflictingOneOf()}
          self.template = .deleteRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    switch self.template {
    case .createRequest?: try {
      guard case .createRequest(let v)? = self.template else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .deleteRequest?: try {
      guard case .deleteRequest(let v)? = self.template else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.TemplateRequest, rhs: Caked_Caked.VMRequest.TemplateRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.template != rhs.template {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.TemplateRequest.TemplateCommand: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0none\0\u{1}add\0\u{1}delete\0\u{1}list\0")
}

extension Caked_Caked.VMRequest.TemplateRequest.TemplateRequestAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.TemplateRequest.protoMessageName + ".TemplateRequestAdd"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sourceName\0\u{1}templateName\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.templateName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceName, fieldNumber: 1)
    }
    if !self.templateName.isEmpty {
      try visitor.visitSingularStringField(value: self.templateName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.TemplateRequest.TemplateRequestAdd, rhs: Caked_Caked.VMRequest.TemplateRequest.TemplateRequestAdd) -> Bool {
    if lhs.sourceName != rhs.sourceName {return false}
    if lhs.templateName != rhs.templateName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.RunCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".RunCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vmname\0\u{1}command\0\u{1}args\0\u{1}input\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vmname) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._input) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.vmname.isEmpty {
      try visitor.visitSingularStringField(value: self.vmname, fieldNumber: 1)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.RunCommand, rhs: Caked_Caked.VMRequest.RunCommand) -> Bool {
    if lhs.vmname != rhs.vmname {return false}
    if lhs.command != rhs.command {return false}
    if lhs.args != rhs.args {return false}
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.ExecuteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".ExecuteResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}exitCode\0\u{1}stdout\0\u{1}stderr\0\u{1}failure\0\u{1}established\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .exitCode(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .stdout(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .stderr(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .failure(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .established(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .exitCode?: try {
      guard case .exitCode(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .stdout?: try {
      guard case .stdout(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .stderr?: try {
      guard case .stderr(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .established?: try {
      guard case .established(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.ExecuteResponse, rhs: Caked_Caked.VMRequest.ExecuteResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.ExecuteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.protoMessageName + ".ExecuteRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}input\0\u{1}size\0\u{1}eof\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand?
        var hadOneofValue = false
        if let current = self.execute {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.execute = .command(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.execute != nil {try decoder.handleConflictingOneOf()}
          self.execute = .input(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.VMRequest.ExecuteRequest.TerminalSize?
        var hadOneofValue = false
        if let current = self.execute {
          hadOneofValue = true
          if case .size(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.execute = .size(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.execute != nil {try decoder.handleConflictingOneOf()}
          self.execute = .eof(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.execute {
    case .command?: try {
      guard case .command(let v)? = self.execute else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .input?: try {
      guard case .input(let v)? = self.execute else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .size?: try {
      guard case .size(let v)? = self.execute else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .eof?: try {
      guard case .eof(let v)? = self.execute else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.ExecuteRequest, rhs: Caked_Caked.VMRequest.ExecuteRequest) -> Bool {
    if lhs.execute != rhs.execute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.ExecuteRequest.protoMessageName + ".ExecuteCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}shell\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.Command?
        var hadOneofValue = false
        if let current = self.execute {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.execute = .command(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.execute != nil {try decoder.handleConflictingOneOf()}
          self.execute = .shell(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.execute {
    case .command?: try {
      guard case .command(let v)? = self.execute else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .shell?: try {
      guard case .shell(let v)? = self.execute else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand, rhs: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand) -> Bool {
    if lhs.execute != rhs.execute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.protoMessageName + ".Command"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}args\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.Command, rhs: Caked_Caked.VMRequest.ExecuteRequest.ExecuteCommand.Command) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.VMRequest.ExecuteRequest.TerminalSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.VMRequest.ExecuteRequest.protoMessageName + ".TerminalSize"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rows\0\u{1}cols\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rows) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.cols) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rows != 0 {
      try visitor.visitSingularInt32Field(value: self.rows, fieldNumber: 1)
    }
    if self.cols != 0 {
      try visitor.visitSingularInt32Field(value: self.cols, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.VMRequest.ExecuteRequest.TerminalSize, rhs: Caked_Caked.VMRequest.ExecuteRequest.TerminalSize) -> Bool {
    if lhs.rows != rhs.rows {return false}
    if lhs.cols != rhs.cols {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".Reply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vms\0\u{1}images\0\u{1}networks\0\u{1}remotes\0\u{1}templates\0\u{1}run\0\u{1}mounts\0\u{1}oci\0\u{1}ping\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.VirtualMachineReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .vms(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .vms(v)
        }
      }()
      case 2: try {
        var v: Caked_Caked.Reply.ImageReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .images(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .images(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.NetworksReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .networks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .networks(v)
        }
      }()
      case 4: try {
        var v: Caked_Caked.Reply.RemoteReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .remotes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .remotes(v)
        }
      }()
      case 5: try {
        var v: Caked_Caked.Reply.TemplateReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .templates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .templates(v)
        }
      }()
      case 6: try {
        var v: Caked_Caked.Reply.RunReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .run(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .run(v)
        }
      }()
      case 7: try {
        var v: Caked_Caked.Reply.MountReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .mounts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .mounts(v)
        }
      }()
      case 8: try {
        var v: Caked_Caked.Reply.OCIReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .oci(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .oci(v)
        }
      }()
      case 9: try {
        var v: Caked_Caked.Reply.PingReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .ping(v)
        }
      }()
      case 10: try {
        var v: Caked_Caked.Reply.CurrentStatusReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .status(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .vms?: try {
      guard case .vms(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .images?: try {
      guard case .images(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .networks?: try {
      guard case .networks(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .remotes?: try {
      guard case .remotes(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .templates?: try {
      guard case .templates(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .run?: try {
      guard case .run(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .mounts?: try {
      guard case .mounts(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .oci?: try {
      guard case .oci(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .status?: try {
      guard case .status(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply, rhs: Caked_Caked.Reply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.CurrentUsageReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".CurrentUsageReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cpuCount\0\u{1}cpuInfos\0\u{1}memory\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.cpuCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cpuInfos) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.cpuCount != 0 {
      try visitor.visitSingularInt32Field(value: self.cpuCount, fieldNumber: 1)
    }
    try { if let v = self._cpuInfos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.CurrentUsageReply, rhs: Caked_Caked.Reply.CurrentUsageReply) -> Bool {
    if lhs.cpuCount != rhs.cpuCount {return false}
    if lhs._cpuInfos != rhs._cpuInfos {return false}
    if lhs._memory != rhs._memory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.CurrentStatusReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".CurrentStatusReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}usage\0\u{1}screenshot\0\u{1}currentStatus\0\u{1}failure\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.CurrentUsageReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .usage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .usage(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .screenshot(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.VirtualMachineStatus?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .currentStatus(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .failure(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .usage?: try {
      guard case .usage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .screenshot?: try {
      guard case .screenshot(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .currentStatus?: try {
      guard case .currentStatus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.CurrentStatusReply, rhs: Caked_Caked.Reply.CurrentStatusReply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.PingReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".PingReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0\u{1}currentStatus\0\u{3}request_timestamp\0\u{3}response_timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.currentStatus) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.requestTimestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.responseTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.currentStatus != .stopped {
      try visitor.visitSingularEnumField(value: self.currentStatus, fieldNumber: 3)
    }
    if self.requestTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.requestTimestamp, fieldNumber: 4)
    }
    if self.responseTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.responseTimestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.PingReply, rhs: Caked_Caked.Reply.PingReply) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.currentStatus != rhs.currentStatus {return false}
    if lhs.requestTimestamp != rhs.requestTimestamp {return false}
    if lhs.responseTimestamp != rhs.responseTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".VirtualMachineReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}delete\0\u{1}stop\0\u{1}suspend\0\u{1}status\0\u{1}launched\0\u{1}started\0\u{1}build\0\u{1}cloned\0\u{1}configured\0\u{1}duplicated\0\u{1}imported\0\u{1}waitip\0\u{1}purged\0\u{1}renamed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .list(v)
        }
      }()
      case 2: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.DeleteReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .delete(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.StopReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .stop(v)
        }
      }()
      case 4: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.SuspendReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .suspend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .suspend(v)
        }
      }()
      case 5: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.StatusReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .status(v)
        }
      }()
      case 6: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.LaunchReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .launched(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .launched(v)
        }
      }()
      case 7: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.StartedReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .started(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .started(v)
        }
      }()
      case 8: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.BuildStreamReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .build(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .build(v)
        }
      }()
      case 9: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.ClonedReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .cloned(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .cloned(v)
        }
      }()
      case 10: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.ConfiguredReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .configured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .configured(v)
        }
      }()
      case 11: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.DuplicatedReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .duplicated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .duplicated(v)
        }
      }()
      case 12: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.ImportedReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .imported(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .imported(v)
        }
      }()
      case 13: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.WaitIPReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .waitip(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .waitip(v)
        }
      }()
      case 14: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.PurgeReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .purged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .purged(v)
        }
      }()
      case 15: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.RenameReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .renamed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .renamed(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .list?: try {
      guard case .list(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .suspend?: try {
      guard case .suspend(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .status?: try {
      guard case .status(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .launched?: try {
      guard case .launched(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .started?: try {
      guard case .started(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .build?: try {
      guard case .build(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .cloned?: try {
      guard case .cloned(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .configured?: try {
      guard case .configured(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .duplicated?: try {
      guard case .duplicated(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .imported?: try {
      guard case .imported(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .waitip?: try {
      guard case .waitip(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .purged?: try {
      guard case .purged(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .renamed?: try {
      guard case .renamed(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply, rhs: Caked_Caked.Reply.VirtualMachineReply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".VirtualMachineInfoReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}infos\0\u{1}reason\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply, rhs: Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply) -> Bool {
    if lhs.infos != rhs.infos {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply.VirtualMachineInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply.protoMessageName + ".VirtualMachineInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}source\0\u{1}name\0\u{1}fqn\0\u{1}instanceID\0\u{1}diskSize\0\u{1}sizeOnDisk\0\u{1}state\0\u{1}ip\0\u{1}fingerprint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.fqn) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._instanceID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.diskSize) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.sizeOnDisk) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._ip) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._fingerprint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.fqn.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fqn, fieldNumber: 4)
    }
    try { if let v = self._instanceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if self.diskSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.diskSize, fieldNumber: 6)
    }
    if self.sizeOnDisk != 0 {
      try visitor.visitSingularUInt64Field(value: self.sizeOnDisk, fieldNumber: 7)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 8)
    }
    try { if let v = self._ip {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._fingerprint {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply.VirtualMachineInfo, rhs: Caked_Caked.Reply.VirtualMachineReply.VirtualMachineInfoReply.VirtualMachineInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.source != rhs.source {return false}
    if lhs.name != rhs.name {return false}
    if lhs.fqn != rhs.fqn {return false}
    if lhs._instanceID != rhs._instanceID {return false}
    if lhs.diskSize != rhs.diskSize {return false}
    if lhs.sizeOnDisk != rhs.sizeOnDisk {return false}
    if lhs.state != rhs.state {return false}
    if lhs._ip != rhs._ip {return false}
    if lhs._fingerprint != rhs._fingerprint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.DeleteReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".DeleteReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}objects\0\u{1}reason\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.DeleteReply, rhs: Caked_Caked.Reply.VirtualMachineReply.DeleteReply) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.DeleteReply.DeletedObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.DeleteReply.protoMessageName + ".DeletedObject"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}source\0\u{1}name\0\u{1}deleted\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.DeleteReply.DeletedObject, rhs: Caked_Caked.Reply.VirtualMachineReply.DeleteReply.DeletedObject) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.name != rhs.name {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StopReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".StopReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}reason\0\u{1}objects\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StopReply, rhs: Caked_Caked.Reply.VirtualMachineReply.StopReply) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StopReply.StoppedObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StopReply.protoMessageName + ".StoppedObject"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}stopped\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.stopped) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.stopped != false {
      try visitor.visitSingularBoolField(value: self.stopped, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StopReply.StoppedObject, rhs: Caked_Caked.Reply.VirtualMachineReply.StopReply.StoppedObject) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.stopped != rhs.stopped {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.SuspendReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".SuspendReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}objects\0\u{1}reason\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.SuspendReply, rhs: Caked_Caked.Reply.VirtualMachineReply.SuspendReply) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.SuspendReply.SuspendedObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.SuspendReply.protoMessageName + ".SuspendedObject"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}suspended\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.suspended) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.suspended != false {
      try visitor.visitSingularBoolField(value: self.suspended, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.SuspendReply.SuspendedObject, rhs: Caked_Caked.Reply.VirtualMachineReply.SuspendReply.SuspendedObject) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.suspended != rhs.suspended {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".StatusReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}status\0\u{1}reason\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.protoMessageName + ".InfoReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{1}uptime\0\u{1}memory\0\u{1}cpuCount\0\u{1}diskInfos\0\u{1}ipaddresses\0\u{1}osname\0\u{1}hostname\0\u{1}release\0\u{1}status\0\u{1}mounts\0\u{1}name\0\u{1}networks\0\u{1}tunnels\0\u{1}sockets\0\u{1}cpu\0\u{1}vncURL\0\u{1}agentVersion\0\u{1}reason\0\u{1}success\0")

  fileprivate class _StorageClass {
    var _version: String? = nil
    var _uptime: UInt64? = nil
    var _memory: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo? = nil
    var _cpuCount: Int32 = 0
    var _diskInfos: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.DiskInfo] = []
    var _ipaddresses: [String] = []
    var _osname: String = String()
    var _hostname: String? = nil
    var _release: String? = nil
    var _status: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.VirtualMachineStatus = .stopped
    var _mounts: [String] = []
    var _name: String = String()
    var _networks: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.AttachedNetwork] = []
    var _tunnels: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo] = []
    var _sockets: [Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.SocketInfo] = []
    var _cpu: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo? = nil
    var _vncURL: String? = nil
    var _agentVersion: String = String()
    var _reason: String? = nil
    var _success: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _uptime = source._uptime
      _memory = source._memory
      _cpuCount = source._cpuCount
      _diskInfos = source._diskInfos
      _ipaddresses = source._ipaddresses
      _osname = source._osname
      _hostname = source._hostname
      _release = source._release
      _status = source._status
      _mounts = source._mounts
      _name = source._name
      _networks = source._networks
      _tunnels = source._tunnels
      _sockets = source._sockets
      _cpu = source._cpu
      _vncURL = source._vncURL
      _agentVersion = source._agentVersion
      _reason = source._reason
      _success = source._success
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._uptime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._memory) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._cpuCount) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._diskInfos) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._ipaddresses) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._osname) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._release) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._mounts) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._networks) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._tunnels) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._sockets) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._cpu) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._vncURL) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._agentVersion) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._reason) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._success) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._version {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._uptime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memory {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._cpuCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cpuCount, fieldNumber: 4)
      }
      if !_storage._diskInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._diskInfos, fieldNumber: 5)
      }
      if !_storage._ipaddresses.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ipaddresses, fieldNumber: 6)
      }
      if !_storage._osname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._osname, fieldNumber: 7)
      }
      try { if let v = _storage._hostname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._release {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      if _storage._status != .stopped {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 10)
      }
      if !_storage._mounts.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._mounts, fieldNumber: 11)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 12)
      }
      if !_storage._networks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._networks, fieldNumber: 13)
      }
      if !_storage._tunnels.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tunnels, fieldNumber: 14)
      }
      if !_storage._sockets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sockets, fieldNumber: 15)
      }
      try { if let v = _storage._cpu {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._vncURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      if !_storage._agentVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._agentVersion, fieldNumber: 18)
      }
      try { if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._uptime != rhs_storage._uptime {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._cpuCount != rhs_storage._cpuCount {return false}
        if _storage._diskInfos != rhs_storage._diskInfos {return false}
        if _storage._ipaddresses != rhs_storage._ipaddresses {return false}
        if _storage._osname != rhs_storage._osname {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._release != rhs_storage._release {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._mounts != rhs_storage._mounts {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._networks != rhs_storage._networks {return false}
        if _storage._tunnels != rhs_storage._tunnels {return false}
        if _storage._sockets != rhs_storage._sockets {return false}
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._vncURL != rhs_storage._vncURL {return false}
        if _storage._agentVersion != rhs_storage._agentVersion {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._success != rhs_storage._success {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.VirtualMachineStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0stopped\0\u{1}running\0\u{1}paused\0\u{1}error\0")
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuCoreInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.protoMessageName + ".CpuCoreInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}core_id\0\u{3}usage_percent\0\u{1}user\0\u{1}system\0\u{1}idle\0\u{1}iowait\0\u{1}irq\0\u{1}softirq\0\u{1}steal\0\u{1}guest\0\u{1}guestNice\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.coreID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.usagePercent) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.user) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.system) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.idle) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.iowait) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.irq) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.softirq) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.steal) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.guest) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self.guestNice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coreID != 0 {
      try visitor.visitSingularInt32Field(value: self.coreID, fieldNumber: 1)
    }
    if self.usagePercent.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.usagePercent, fieldNumber: 2)
    }
    if self.user.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.user, fieldNumber: 3)
    }
    if self.system.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.system, fieldNumber: 4)
    }
    if self.idle.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.idle, fieldNumber: 5)
    }
    if self.iowait.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.iowait, fieldNumber: 6)
    }
    if self.irq.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.irq, fieldNumber: 7)
    }
    if self.softirq.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.softirq, fieldNumber: 8)
    }
    if self.steal.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.steal, fieldNumber: 9)
    }
    if self.guest.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.guest, fieldNumber: 10)
    }
    if self.guestNice.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.guestNice, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuCoreInfo, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuCoreInfo) -> Bool {
    if lhs.coreID != rhs.coreID {return false}
    if lhs.usagePercent != rhs.usagePercent {return false}
    if lhs.user != rhs.user {return false}
    if lhs.system != rhs.system {return false}
    if lhs.idle != rhs.idle {return false}
    if lhs.iowait != rhs.iowait {return false}
    if lhs.irq != rhs.irq {return false}
    if lhs.softirq != rhs.softirq {return false}
    if lhs.steal != rhs.steal {return false}
    if lhs.guest != rhs.guest {return false}
    if lhs.guestNice != rhs.guestNice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.protoMessageName + ".CpuInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}total_usage_percent\0\u{1}user\0\u{1}system\0\u{1}idle\0\u{1}iowait\0\u{1}irq\0\u{1}softirq\0\u{1}steal\0\u{1}guest\0\u{1}guestNice\0\u{1}cores\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.totalUsagePercent) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.user) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.system) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.idle) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.iowait) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.irq) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.softirq) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.steal) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.guest) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.guestNice) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.cores) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalUsagePercent.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.totalUsagePercent, fieldNumber: 1)
    }
    if self.user.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.user, fieldNumber: 2)
    }
    if self.system.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.system, fieldNumber: 3)
    }
    if self.idle.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.idle, fieldNumber: 4)
    }
    if self.iowait.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.iowait, fieldNumber: 5)
    }
    if self.irq.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.irq, fieldNumber: 6)
    }
    if self.softirq.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.softirq, fieldNumber: 7)
    }
    if self.steal.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.steal, fieldNumber: 8)
    }
    if self.guest.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.guest, fieldNumber: 9)
    }
    if self.guestNice.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.guestNice, fieldNumber: 10)
    }
    if !self.cores.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cores, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.CpuInfo) -> Bool {
    if lhs.totalUsagePercent != rhs.totalUsagePercent {return false}
    if lhs.user != rhs.user {return false}
    if lhs.system != rhs.system {return false}
    if lhs.idle != rhs.idle {return false}
    if lhs.iowait != rhs.iowait {return false}
    if lhs.irq != rhs.irq {return false}
    if lhs.softirq != rhs.softirq {return false}
    if lhs.steal != rhs.steal {return false}
    if lhs.guest != rhs.guest {return false}
    if lhs.guestNice != rhs.guestNice {return false}
    if lhs.cores != rhs.cores {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.protoMessageName + ".MemoryInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}total\0\u{1}free\0\u{1}used\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._free) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._used) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.total != 0 {
      try visitor.visitSingularUInt64Field(value: self.total, fieldNumber: 1)
    }
    try { if let v = self._free {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._used {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.MemoryInfo) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs._free != rhs._free {return false}
    if lhs._used != rhs._used {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.DiskInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.protoMessageName + ".DiskInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}device\0\u{1}mount\0\u{1}fsType\0\u{1}size\0\u{1}used\0\u{1}free\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.device) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fsType) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.used) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.free) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 1)
    }
    if !self.mount.isEmpty {
      try visitor.visitSingularStringField(value: self.mount, fieldNumber: 2)
    }
    if !self.fsType.isEmpty {
      try visitor.visitSingularStringField(value: self.fsType, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 4)
    }
    if self.used != 0 {
      try visitor.visitSingularUInt64Field(value: self.used, fieldNumber: 5)
    }
    if self.free != 0 {
      try visitor.visitSingularUInt64Field(value: self.free, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.DiskInfo, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.DiskInfo) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.mount != rhs.mount {return false}
    if lhs.fsType != rhs.fsType {return false}
    if lhs.size != rhs.size {return false}
    if lhs.used != rhs.used {return false}
    if lhs.free != rhs.free {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.AttachedNetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.protoMessageName + ".AttachedNetwork"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}network\0\u{1}mode\0\u{1}macAddress\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._mode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._macAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 1)
    }
    try { if let v = self._mode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._macAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.AttachedNetwork, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.AttachedNetwork) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs._macAddress != rhs._macAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.protoMessageName + ".TunnelInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}forward\0\u{1}unixDomain\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ForwardedPort?
        var hadOneofValue = false
        if let current = self.tunnel {
          hadOneofValue = true
          if case .forward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tunnel = .forward(v)
        }
      }()
      case 2: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.Tunnel?
        var hadOneofValue = false
        if let current = self.tunnel {
          hadOneofValue = true
          if case .unixDomain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tunnel = .unixDomain(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.tunnel {
    case .forward?: try {
      guard case .forward(let v)? = self.tunnel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unixDomain?: try {
      guard case .unixDomain(let v)? = self.tunnel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo) -> Bool {
    if lhs.tunnel != rhs.tunnel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ProtocolEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0tcp\0\u{1}udp\0")
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ForwardedPort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.protoMessageName + ".ForwardedPort"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}protocol\0\u{1}host\0\u{1}guest\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`protocol`) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.host) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.guest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`protocol` != .tcp {
      try visitor.visitSingularEnumField(value: self.`protocol`, fieldNumber: 1)
    }
    if self.host != 0 {
      try visitor.visitSingularInt32Field(value: self.host, fieldNumber: 2)
    }
    if self.guest != 0 {
      try visitor.visitSingularInt32Field(value: self.guest, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ForwardedPort, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.ForwardedPort) -> Bool {
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.host != rhs.host {return false}
    if lhs.guest != rhs.guest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.Tunnel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.protoMessageName + ".Tunnel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}protocol\0\u{1}host\0\u{1}guest\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`protocol`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.guest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`protocol` != .tcp {
      try visitor.visitSingularEnumField(value: self.`protocol`, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    if !self.guest.isEmpty {
      try visitor.visitSingularStringField(value: self.guest, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.Tunnel, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.TunnelInfo.Tunnel) -> Bool {
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.host != rhs.host {return false}
    if lhs.guest != rhs.guest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.SocketInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.protoMessageName + ".SocketInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mode\0\u{1}host\0\u{1}port\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .bind {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.SocketInfo, rhs: Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.SocketInfo) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StatusReply.InfoReply.SocketInfo.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0bind\0\u{1}connect\0\u{1}tcp\0\u{1}udp\0")
}

extension Caked_Caked.Reply.VirtualMachineReply.LaunchReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".LaunchReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}address\0\u{1}launched\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._address) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.launched) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.launched != false {
      try visitor.visitSingularBoolField(value: self.launched, fieldNumber: 3)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.LaunchReply, rhs: Caked_Caked.Reply.VirtualMachineReply.LaunchReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._address != rhs._address {return false}
    if lhs.launched != rhs.launched {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.StartedReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".StartedReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}address\0\u{1}started\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._address) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.started) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._address {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.started != false {
      try visitor.visitSingularBoolField(value: self.started, fieldNumber: 3)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.StartedReply, rhs: Caked_Caked.Reply.VirtualMachineReply.StartedReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._address != rhs._address {return false}
    if lhs.started != rhs.started {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.BuildedReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".BuildedReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}builded\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.builded) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.builded != false {
      try visitor.visitSingularBoolField(value: self.builded, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.BuildedReply, rhs: Caked_Caked.Reply.VirtualMachineReply.BuildedReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.builded != rhs.builded {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.BuildProgressValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".BuildProgressValue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}oldFractionCompleted\0\u{1}fractionCompleted\0\u{1}lastCompleted10\0\u{1}lastCompleted2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.oldFractionCompleted) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.fractionCompleted) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lastCompleted10) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.lastCompleted2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oldFractionCompleted.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.oldFractionCompleted, fieldNumber: 1)
    }
    if self.fractionCompleted.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fractionCompleted, fieldNumber: 2)
    }
    if self.lastCompleted10 != 0 {
      try visitor.visitSingularInt32Field(value: self.lastCompleted10, fieldNumber: 3)
    }
    if self.lastCompleted2 != 0 {
      try visitor.visitSingularInt32Field(value: self.lastCompleted2, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.BuildProgressValue, rhs: Caked_Caked.Reply.VirtualMachineReply.BuildProgressValue) -> Bool {
    if lhs.oldFractionCompleted != rhs.oldFractionCompleted {return false}
    if lhs.fractionCompleted != rhs.fractionCompleted {return false}
    if lhs.lastCompleted10 != rhs.lastCompleted10 {return false}
    if lhs.lastCompleted2 != rhs.lastCompleted2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.BuildTerminatedReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".BuildTerminatedReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}failure\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .failure(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.BuildTerminatedReply, rhs: Caked_Caked.Reply.VirtualMachineReply.BuildTerminatedReply) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.BuildStreamReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".BuildStreamReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}progress\0\u{1}step\0\u{1}terminated\0\u{1}builded\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.BuildProgressValue?
        var hadOneofValue = false
        if let current = self.current {
          hadOneofValue = true
          if case .progress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.current = .progress(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.current != nil {try decoder.handleConflictingOneOf()}
          self.current = .step(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.BuildTerminatedReply?
        var hadOneofValue = false
        if let current = self.current {
          hadOneofValue = true
          if case .terminated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.current = .terminated(v)
        }
      }()
      case 4: try {
        var v: Caked_Caked.Reply.VirtualMachineReply.BuildedReply?
        var hadOneofValue = false
        if let current = self.current {
          hadOneofValue = true
          if case .builded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.current = .builded(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.current {
    case .progress?: try {
      guard case .progress(let v)? = self.current else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .step?: try {
      guard case .step(let v)? = self.current else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .terminated?: try {
      guard case .terminated(let v)? = self.current else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .builded?: try {
      guard case .builded(let v)? = self.current else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.BuildStreamReply, rhs: Caked_Caked.Reply.VirtualMachineReply.BuildStreamReply) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.ClonedReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".ClonedReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sourceName\0\u{1}targetName\0\u{1}cloned\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.cloned) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceName, fieldNumber: 1)
    }
    if !self.targetName.isEmpty {
      try visitor.visitSingularStringField(value: self.targetName, fieldNumber: 2)
    }
    if self.cloned != false {
      try visitor.visitSingularBoolField(value: self.cloned, fieldNumber: 3)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.ClonedReply, rhs: Caked_Caked.Reply.VirtualMachineReply.ClonedReply) -> Bool {
    if lhs.sourceName != rhs.sourceName {return false}
    if lhs.targetName != rhs.targetName {return false}
    if lhs.cloned != rhs.cloned {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.ConfiguredReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".ConfiguredReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}configured\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.configured) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.configured != false {
      try visitor.visitSingularBoolField(value: self.configured, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.ConfiguredReply, rhs: Caked_Caked.Reply.VirtualMachineReply.ConfiguredReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configured != rhs.configured {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.DuplicatedReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".DuplicatedReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}from\0\u{1}to\0\u{1}duplicated\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.duplicated) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    if self.duplicated != false {
      try visitor.visitSingularBoolField(value: self.duplicated, fieldNumber: 3)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.DuplicatedReply, rhs: Caked_Caked.Reply.VirtualMachineReply.DuplicatedReply) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.duplicated != rhs.duplicated {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.ImportedReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".ImportedReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}source\0\u{1}imported\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.imported) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 2)
    }
    if self.imported != false {
      try visitor.visitSingularBoolField(value: self.imported, fieldNumber: 3)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.ImportedReply, rhs: Caked_Caked.Reply.VirtualMachineReply.ImportedReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.source != rhs.source {return false}
    if lhs.imported != rhs.imported {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.WaitIPReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".WaitIPReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}ip\0\u{1}success\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 2)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.WaitIPReply, rhs: Caked_Caked.Reply.VirtualMachineReply.WaitIPReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.success != rhs.success {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.PurgeReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".PurgeReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}purged\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.purged) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.purged != false {
      try visitor.visitSingularBoolField(value: self.purged, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.PurgeReply, rhs: Caked_Caked.Reply.VirtualMachineReply.PurgeReply) -> Bool {
    if lhs.purged != rhs.purged {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.VirtualMachineReply.RenameReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.VirtualMachineReply.protoMessageName + ".RenameReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}oldName\0\u{1}newName\0\u{1}renamed\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oldName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.renamed) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.oldName.isEmpty {
      try visitor.visitSingularStringField(value: self.oldName, fieldNumber: 1)
    }
    if !self.newName.isEmpty {
      try visitor.visitSingularStringField(value: self.newName, fieldNumber: 2)
    }
    if self.renamed != false {
      try visitor.visitSingularBoolField(value: self.renamed, fieldNumber: 3)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.VirtualMachineReply.RenameReply, rhs: Caked_Caked.Reply.VirtualMachineReply.RenameReply) -> Bool {
    if lhs.oldName != rhs.oldName {return false}
    if lhs.newName != rhs.newName {return false}
    if lhs.renamed != rhs.renamed {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.ImageReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".ImageReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}infos\0\u{1}pull\0\u{1}list\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.ImageReply.ImageInfoReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .infos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .infos(v)
        }
      }()
      case 2: try {
        var v: Caked_Caked.Reply.ImageReply.PulledImageInfoReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .pull(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .pull(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.ImageReply.ListImagesInfoReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .list(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .infos?: try {
      guard case .infos(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pull?: try {
      guard case .pull(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .list?: try {
      guard case .list(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.ImageReply, rhs: Caked_Caked.Reply.ImageReply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.ImageReply.ImageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.ImageReply.protoMessageName + ".ImageInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}aliases\0\u{1}architecture\0\u{1}pub\0\u{1}fileName\0\u{1}fingerprint\0\u{1}size\0\u{1}type\0\u{1}created\0\u{1}expires\0\u{1}uploaded\0\u{1}properties\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.aliases) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.pub) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fingerprint) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._created) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._expires) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._uploaded) }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.aliases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.aliases, fieldNumber: 1)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 2)
    }
    if self.pub != false {
      try visitor.visitSingularBoolField(value: self.pub, fieldNumber: 3)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 4)
    }
    if !self.fingerprint.isEmpty {
      try visitor.visitSingularStringField(value: self.fingerprint, fieldNumber: 5)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 6)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 7)
    }
    try { if let v = self._created {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._expires {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._uploaded {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.properties, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.ImageReply.ImageInfo, rhs: Caked_Caked.Reply.ImageReply.ImageInfo) -> Bool {
    if lhs.aliases != rhs.aliases {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.pub != rhs.pub {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.fingerprint != rhs.fingerprint {return false}
    if lhs.size != rhs.size {return false}
    if lhs.type != rhs.type {return false}
    if lhs._created != rhs._created {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs._uploaded != rhs._uploaded {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.ImageReply.ListImagesInfoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.ImageReply.protoMessageName + ".ListImagesInfoReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}reason\0\u{1}infos\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.ImageReply.ListImagesInfoReply, rhs: Caked_Caked.Reply.ImageReply.ListImagesInfoReply) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.infos != rhs.infos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.ImageReply.ImageInfoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.ImageReply.protoMessageName + ".ImageInfoReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{1}reason\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.ImageReply.ImageInfoReply, rhs: Caked_Caked.Reply.ImageReply.ImageInfoReply) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.ImageReply.PulledImageInfoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.ImageReply.protoMessageName + ".PulledImageInfoReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{1}reason\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.ImageReply.PulledImageInfoReply, rhs: Caked_Caked.Reply.ImageReply.PulledImageInfoReply) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.ImageReply.PulledImageInfoReply.PulledImageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.ImageReply.PulledImageInfoReply.protoMessageName + ".PulledImageInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}alias\0\u{1}path\0\u{1}size\0\u{1}fingerprint\0\u{1}remoteName\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._alias) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fingerprint) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.remoteName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._alias {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 3)
    }
    if !self.fingerprint.isEmpty {
      try visitor.visitSingularStringField(value: self.fingerprint, fieldNumber: 4)
    }
    if !self.remoteName.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteName, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.ImageReply.PulledImageInfoReply.PulledImageInfo, rhs: Caked_Caked.Reply.ImageReply.PulledImageInfoReply.PulledImageInfo) -> Bool {
    if lhs._alias != rhs._alias {return false}
    if lhs.path != rhs.path {return false}
    if lhs.size != rhs.size {return false}
    if lhs.fingerprint != rhs.fingerprint {return false}
    if lhs.remoteName != rhs.remoteName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".NetworksReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}status\0\u{1}created\0\u{1}configured\0\u{1}delete\0\u{1}started\0\u{1}stopped\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.NetworksReply.ListNetworksReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .list(v)
        }
      }()
      case 2: try {
        var v: Caked_Caked.Reply.NetworksReply.NetworkInfoReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .status(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.NetworksReply.CreatedNetworkReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .created(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .created(v)
        }
      }()
      case 4: try {
        var v: Caked_Caked.Reply.NetworksReply.ConfiguredNetworkReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .configured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .configured(v)
        }
      }()
      case 5: try {
        var v: Caked_Caked.Reply.NetworksReply.DeleteNetworkReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .delete(v)
        }
      }()
      case 6: try {
        var v: Caked_Caked.Reply.NetworksReply.StartedNetworkReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .started(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .started(v)
        }
      }()
      case 7: try {
        var v: Caked_Caked.Reply.NetworksReply.StoppedNetworkReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .stopped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .stopped(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .list?: try {
      guard case .list(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .status?: try {
      guard case .status(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .created?: try {
      guard case .created(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .configured?: try {
      guard case .configured(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .started?: try {
      guard case .started(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .stopped?: try {
      guard case .stopped(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply, rhs: Caked_Caked.Reply.NetworksReply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply.NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.NetworksReply.protoMessageName + ".NetworkInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}mode\0\u{1}description\0\u{1}gateway\0\u{1}dhcpEnd\0\u{1}netmask\0\u{1}interfaceID\0\u{1}endpoint\0\u{1}used\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.dhcpEnd) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.netmask) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.interfaceID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.used) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.mode.isEmpty {
      try visitor.visitSingularStringField(value: self.mode, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 4)
    }
    if !self.dhcpEnd.isEmpty {
      try visitor.visitSingularStringField(value: self.dhcpEnd, fieldNumber: 5)
    }
    if !self.netmask.isEmpty {
      try visitor.visitSingularStringField(value: self.netmask, fieldNumber: 6)
    }
    if !self.interfaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceID, fieldNumber: 7)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 8)
    }
    if self.used != 0 {
      try visitor.visitSingularInt32Field(value: self.used, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply.NetworkInfo, rhs: Caked_Caked.Reply.NetworksReply.NetworkInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.dhcpEnd != rhs.dhcpEnd {return false}
    if lhs.netmask != rhs.netmask {return false}
    if lhs.interfaceID != rhs.interfaceID {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.used != rhs.used {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply.NetworkInfoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.NetworksReply.protoMessageName + ".NetworkInfoReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{1}reason\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply.NetworkInfoReply, rhs: Caked_Caked.Reply.NetworksReply.NetworkInfoReply) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply.ListNetworksReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.NetworksReply.protoMessageName + ".ListNetworksReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}networks\0\u{1}reason\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.networks) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.networks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.networks, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply.ListNetworksReply, rhs: Caked_Caked.Reply.NetworksReply.ListNetworksReply) -> Bool {
    if lhs.networks != rhs.networks {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply.StartedNetworkReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.NetworksReply.protoMessageName + ".StartedNetworkReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}started\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.started) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.started != false {
      try visitor.visitSingularBoolField(value: self.started, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply.StartedNetworkReply, rhs: Caked_Caked.Reply.NetworksReply.StartedNetworkReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.started != rhs.started {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply.StoppedNetworkReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.NetworksReply.protoMessageName + ".StoppedNetworkReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}stopped\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.stopped) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.stopped != false {
      try visitor.visitSingularBoolField(value: self.stopped, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply.StoppedNetworkReply, rhs: Caked_Caked.Reply.NetworksReply.StoppedNetworkReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.stopped != rhs.stopped {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply.CreatedNetworkReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.NetworksReply.protoMessageName + ".CreatedNetworkReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}created\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.created) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.created != false {
      try visitor.visitSingularBoolField(value: self.created, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply.CreatedNetworkReply, rhs: Caked_Caked.Reply.NetworksReply.CreatedNetworkReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.created != rhs.created {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply.ConfiguredNetworkReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.NetworksReply.protoMessageName + ".ConfiguredNetworkReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}configured\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.configured) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.configured != false {
      try visitor.visitSingularBoolField(value: self.configured, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply.ConfiguredNetworkReply, rhs: Caked_Caked.Reply.NetworksReply.ConfiguredNetworkReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configured != rhs.configured {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.NetworksReply.DeleteNetworkReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.NetworksReply.protoMessageName + ".DeleteNetworkReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}deleted\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.NetworksReply.DeleteNetworkReply, rhs: Caked_Caked.Reply.NetworksReply.DeleteNetworkReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.RemoteReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".RemoteReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}deleted\0\u{1}created\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.RemoteReply.ListRemoteReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .list(v)
        }
      }()
      case 2: try {
        var v: Caked_Caked.Reply.RemoteReply.DeleteRemoteReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleted(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.RemoteReply.CreateRemoteReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .created(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .created(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .list?: try {
      guard case .list(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .deleted?: try {
      guard case .deleted(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .created?: try {
      guard case .created(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.RemoteReply, rhs: Caked_Caked.Reply.RemoteReply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.RemoteReply.ListRemoteReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.RemoteReply.protoMessageName + ".ListRemoteReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}remotes\0\u{1}success\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.remotes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.remotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.remotes, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.RemoteReply.ListRemoteReply, rhs: Caked_Caked.Reply.RemoteReply.ListRemoteReply) -> Bool {
    if lhs.remotes != rhs.remotes {return false}
    if lhs.success != rhs.success {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.RemoteReply.ListRemoteReply.RemoteEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.RemoteReply.ListRemoteReply.protoMessageName + ".RemoteEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.RemoteReply.ListRemoteReply.RemoteEntry, rhs: Caked_Caked.Reply.RemoteReply.ListRemoteReply.RemoteEntry) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.RemoteReply.DeleteRemoteReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.RemoteReply.protoMessageName + ".DeleteRemoteReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}deleted\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.RemoteReply.DeleteRemoteReply, rhs: Caked_Caked.Reply.RemoteReply.DeleteRemoteReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.RemoteReply.CreateRemoteReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.RemoteReply.protoMessageName + ".CreateRemoteReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}created\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.created) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.created != false {
      try visitor.visitSingularBoolField(value: self.created, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.RemoteReply.CreateRemoteReply, rhs: Caked_Caked.Reply.RemoteReply.CreateRemoteReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.created != rhs.created {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.TemplateReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".TemplateReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}list\0\u{1}create\0\u{1}delete\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.TemplateReply.ListTemplatesReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .list(v)
        }
      }()
      case 2: try {
        var v: Caked_Caked.Reply.TemplateReply.CreateTemplateReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .create(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.TemplateReply.DeleteTemplateReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .list?: try {
      guard case .list(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .create?: try {
      guard case .create(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.TemplateReply, rhs: Caked_Caked.Reply.TemplateReply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.TemplateReply.ListTemplatesReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.TemplateReply.protoMessageName + ".ListTemplatesReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}templates\0\u{1}success\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.templates) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.templates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.templates, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.TemplateReply.ListTemplatesReply, rhs: Caked_Caked.Reply.TemplateReply.ListTemplatesReply) -> Bool {
    if lhs.templates != rhs.templates {return false}
    if lhs.success != rhs.success {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.TemplateReply.ListTemplatesReply.TemplateEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.TemplateReply.ListTemplatesReply.protoMessageName + ".TemplateEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}fqn\0\u{1}diskSize\0\u{1}totalSize\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fqn) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.diskSize) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fqn.isEmpty {
      try visitor.visitSingularStringField(value: self.fqn, fieldNumber: 2)
    }
    if self.diskSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.diskSize, fieldNumber: 3)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.TemplateReply.ListTemplatesReply.TemplateEntry, rhs: Caked_Caked.Reply.TemplateReply.ListTemplatesReply.TemplateEntry) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fqn != rhs.fqn {return false}
    if lhs.diskSize != rhs.diskSize {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.TemplateReply.CreateTemplateReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.TemplateReply.protoMessageName + ".CreateTemplateReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}created\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.created) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.created != false {
      try visitor.visitSingularBoolField(value: self.created, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.TemplateReply.CreateTemplateReply, rhs: Caked_Caked.Reply.TemplateReply.CreateTemplateReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.created != rhs.created {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.TemplateReply.DeleteTemplateReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.TemplateReply.protoMessageName + ".DeleteTemplateReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}deleted\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 2)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.TemplateReply.DeleteTemplateReply, rhs: Caked_Caked.Reply.TemplateReply.DeleteTemplateReply) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.RunReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".RunReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}exitCode\0\u{1}stdout\0\u{1}stderr\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.stdout) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.stderr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 1)
    }
    if !self.stdout.isEmpty {
      try visitor.visitSingularBytesField(value: self.stdout, fieldNumber: 2)
    }
    if !self.stderr.isEmpty {
      try visitor.visitSingularBytesField(value: self.stderr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.RunReply, rhs: Caked_Caked.Reply.RunReply) -> Bool {
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.MountReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".MountReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}reason\0\u{1}mounts\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.mounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mounts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.MountReply, rhs: Caked_Caked.Reply.MountReply) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.mounts != rhs.mounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.MountReply.MountVirtioFSReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.MountReply.protoMessageName + ".MountVirtioFSReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mounted\0\u{1}reason\0\u{1}name\0\u{1}path\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.mounted) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.mounted != false {
      try visitor.visitSingularBoolField(value: self.mounted, fieldNumber: 1)
    }
    try { if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.MountReply.MountVirtioFSReply, rhs: Caked_Caked.Reply.MountReply.MountVirtioFSReply) -> Bool {
    if lhs.mounted != rhs.mounted {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.name != rhs.name {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.OCIReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.protoMessageName + ".OCIReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}login\0\u{1}logout\0\u{1}pull\0\u{1}push\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Caked_Caked.Reply.OCIReply.LoginReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .login(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .login(v)
        }
      }()
      case 2: try {
        var v: Caked_Caked.Reply.OCIReply.LogoutReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .logout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .logout(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.Reply.OCIReply.PullReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .pull(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .pull(v)
        }
      }()
      case 4: try {
        var v: Caked_Caked.Reply.OCIReply.PushReply?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .push(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .push(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .login?: try {
      guard case .login(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .logout?: try {
      guard case .logout(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pull?: try {
      guard case .pull(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .push?: try {
      guard case .push(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.OCIReply, rhs: Caked_Caked.Reply.OCIReply) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.OCIReply.PullReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.OCIReply.protoMessageName + ".PullReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0\u{1}imageType\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.imageType.isEmpty {
      try visitor.visitSingularStringField(value: self.imageType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.OCIReply.PullReply, rhs: Caked_Caked.Reply.OCIReply.PullReply) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.imageType != rhs.imageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.OCIReply.PushReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.OCIReply.protoMessageName + ".PushReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.OCIReply.PushReply, rhs: Caked_Caked.Reply.OCIReply.PushReply) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.OCIReply.LoginReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.OCIReply.protoMessageName + ".LoginReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.OCIReply.LoginReply, rhs: Caked_Caked.Reply.OCIReply.LoginReply) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.Reply.OCIReply.LogoutReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.Reply.OCIReply.protoMessageName + ".LogoutReply"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.Reply.OCIReply.LogoutReply, rhs: Caked_Caked.Reply.OCIReply.LogoutReply) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.NetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".NetworkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}name\0\u{1}create\0\u{1}configure\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.network != nil {try decoder.handleConflictingOneOf()}
          self.network = .name(v)
        }
      }()
      case 3: try {
        var v: Caked_Caked.NetworkRequest.CreateNetworkRequest?
        var hadOneofValue = false
        if let current = self.network {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.network = .create(v)
        }
      }()
      case 4: try {
        var v: Caked_Caked.NetworkRequest.ConfigureNetworkRequest?
        var hadOneofValue = false
        if let current = self.network {
          hadOneofValue = true
          if case .configure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.network = .configure(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.command != .infos {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    switch self.network {
    case .name?: try {
      guard case .name(let v)? = self.network else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .create?: try {
      guard case .create(let v)? = self.network else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .configure?: try {
      guard case .configure(let v)? = self.network else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.NetworkRequest, rhs: Caked_Caked.NetworkRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.NetworkRequest.NetworkMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0shared\0\u{1}host\0")
}

extension Caked_Caked.NetworkRequest.NetworkCommand: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0infos\0\u{1}new\0\u{1}set\0\u{1}start\0\u{1}shutdown\0\u{1}remove\0\u{1}status\0")
}

extension Caked_Caked.NetworkRequest.ConfigureNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.NetworkRequest.protoMessageName + ".ConfigureNetworkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}gateway\0\u{1}dhcpEnd\0\u{1}netmask\0\u{1}uuid\0\u{1}nat66prefix\0\u{1}dhcpLease\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._gateway) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._dhcpEnd) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._netmask) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._uuid) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._nat66Prefix) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._dhcpLease) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._gateway {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dhcpEnd {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._netmask {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._uuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nat66Prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._dhcpLease {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.NetworkRequest.ConfigureNetworkRequest, rhs: Caked_Caked.NetworkRequest.ConfigureNetworkRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._gateway != rhs._gateway {return false}
    if lhs._dhcpEnd != rhs._dhcpEnd {return false}
    if lhs._netmask != rhs._netmask {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs._nat66Prefix != rhs._nat66Prefix {return false}
    if lhs._dhcpLease != rhs._dhcpLease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.NetworkRequest.CreateNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.NetworkRequest.protoMessageName + ".CreateNetworkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mode\0\u{1}name\0\u{1}gateway\0\u{1}dhcpEnd\0\u{1}netmask\0\u{1}uuid\0\u{1}nat66prefix\0\u{1}dhcpLease\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gateway) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dhcpEnd) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.netmask) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._uuid) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._nat66Prefix) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._dhcpLease) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.mode != .shared {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.gateway.isEmpty {
      try visitor.visitSingularStringField(value: self.gateway, fieldNumber: 3)
    }
    if !self.dhcpEnd.isEmpty {
      try visitor.visitSingularStringField(value: self.dhcpEnd, fieldNumber: 4)
    }
    if !self.netmask.isEmpty {
      try visitor.visitSingularStringField(value: self.netmask, fieldNumber: 5)
    }
    try { if let v = self._uuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._nat66Prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._dhcpLease {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.NetworkRequest.CreateNetworkRequest, rhs: Caked_Caked.NetworkRequest.CreateNetworkRequest) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.name != rhs.name {return false}
    if lhs.gateway != rhs.gateway {return false}
    if lhs.dhcpEnd != rhs.dhcpEnd {return false}
    if lhs.netmask != rhs.netmask {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs._nat66Prefix != rhs._nat66Prefix {return false}
    if lhs._dhcpLease != rhs._dhcpLease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.ImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".ImageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.ImageRequest, rhs: Caked_Caked.ImageRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.ImageRequest.ImageCommand: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0none\0\u{1}info\0\u{1}pull\0\u{1}list\0")
}

extension Caked_Caked.RemoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".RemoteRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}addRequest\0\u{1}deleteRequest\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try {
        var v: Caked_Caked.RemoteRequest.RemoteRequestAdd?
        var hadOneofValue = false
        if let current = self.remote {
          hadOneofValue = true
          if case .addRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.remote = .addRequest(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.remote != nil {try decoder.handleConflictingOneOf()}
          self.remote = .deleteRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    switch self.remote {
    case .addRequest?: try {
      guard case .addRequest(let v)? = self.remote else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .deleteRequest?: try {
      guard case .deleteRequest(let v)? = self.remote else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.RemoteRequest, rhs: Caked_Caked.RemoteRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.remote != rhs.remote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.RemoteRequest.RemoteCommand: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0none\0\u{1}list\0\u{1}add\0\u{1}delete\0")
}

extension Caked_Caked.RemoteRequest.RemoteRequestAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.RemoteRequest.protoMessageName + ".RemoteRequestAdd"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}url\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.RemoteRequest.RemoteRequestAdd, rhs: Caked_Caked.RemoteRequest.RemoteRequestAdd) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.PurgeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".PurgeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0\u{1}olderThan\0\u{1}spaceBudget\0\u{2}\u{2}gc\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._entries) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._olderThan) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._spaceBudget) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._gc) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entries {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._olderThan {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._spaceBudget {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gc {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.PurgeRequest, rhs: Caked_Caked.PurgeRequest) -> Bool {
    if lhs._entries != rhs._entries {return false}
    if lhs._olderThan != rhs._olderThan {return false}
    if lhs._spaceBudget != rhs._spaceBudget {return false}
    if lhs._gc != rhs._gc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.PushRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".PushRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}localName\0\u{1}remoteNames\0\u{1}insecure\0\u{1}chunkSize\0\u{1}concurrency\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.remoteNames) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.insecure) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.chunkSize) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.concurrency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localName.isEmpty {
      try visitor.visitSingularStringField(value: self.localName, fieldNumber: 1)
    }
    if !self.remoteNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.remoteNames, fieldNumber: 2)
    }
    if self.insecure != false {
      try visitor.visitSingularBoolField(value: self.insecure, fieldNumber: 3)
    }
    if self.chunkSize != 0 {
      try visitor.visitSingularInt32Field(value: self.chunkSize, fieldNumber: 4)
    }
    if self.concurrency != 0 {
      try visitor.visitSingularInt32Field(value: self.concurrency, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.PushRequest, rhs: Caked_Caked.PushRequest) -> Bool {
    if lhs.localName != rhs.localName {return false}
    if lhs.remoteNames != rhs.remoteNames {return false}
    if lhs.insecure != rhs.insecure {return false}
    if lhs.chunkSize != rhs.chunkSize {return false}
    if lhs.concurrency != rhs.concurrency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.CloneRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".CloneRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}image\0\u{1}insecure\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.image) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.insecure) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 2)
    }
    if self.insecure != false {
      try visitor.visitSingularBoolField(value: self.insecure, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.CloneRequest, rhs: Caked_Caked.CloneRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.image != rhs.image {return false}
    if lhs.insecure != rhs.insecure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".LoginRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}host\0\u{1}username\0\u{1}password\0\u{1}insecure\0\u{1}noValidate\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.insecure) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.noValidate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if self.insecure != false {
      try visitor.visitSingularBoolField(value: self.insecure, fieldNumber: 4)
    }
    if self.noValidate != false {
      try visitor.visitSingularBoolField(value: self.noValidate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.LoginRequest, rhs: Caked_Caked.LoginRequest) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.insecure != rhs.insecure {return false}
    if lhs.noValidate != rhs.noValidate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.LogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".LogoutRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}host\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.LogoutRequest, rhs: Caked_Caked.LogoutRequest) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.MountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.protoMessageName + ".MountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}name\0\u{1}mounts\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.mounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mounts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.MountRequest, rhs: Caked_Caked.MountRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.name != rhs.name {return false}
    if lhs.mounts != rhs.mounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Caked_Caked.MountRequest.MountCommand: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0none\0\u{1}mount\0\u{1}umount\0")
}

extension Caked_Caked.MountRequest.MountVirtioFS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Caked_Caked.MountRequest.protoMessageName + ".MountVirtioFS"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}source\0\u{1}target\0\u{1}name\0\u{1}uid\0\u{1}gid\0\u{1}readonly\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._uid) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._gid) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.readonly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    try { if let v = self._target {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._uid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if self.readonly != false {
      try visitor.visitSingularBoolField(value: self.readonly, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Caked_Caked.MountRequest.MountVirtioFS, rhs: Caked_Caked.MountRequest.MountVirtioFS) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._target != rhs._target {return false}
    if lhs._name != rhs._name {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._gid != rhs._gid {return false}
    if lhs.readonly != rhs.readonly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
